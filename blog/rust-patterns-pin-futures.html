<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #19: Pin and Boxing Futures - Telex</title>
  <meta name="description" content="Pinning means 'this value won't move in memory' â€” and async needs that guarantee. The mental model for Pin, Box::pin, and why trait methods that return futures need boxing.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #19: Pin and Boxing Futures</h1>
      <div class="post-meta">September 2026</div>
      <p class="series-nav">Post 19 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        You write an async trait method, or try to store a future in a struct, and the
        compiler demands <code>Pin</code>. You don't know what <code>Pin</code> does or
        why async needs it. This post explains both.
      </p>

      <h2>The motivation</h2>

      <p>
        You want a trait with an async method:
      </p>

      <pre><code><span class="kw">trait</span> <span class="ty">DataSource</span> {
    <span class="kw">async fn</span> <span class="fn">fetch</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">Vec</span>&lt;<span class="ty">u8</span>&gt;;
}</code></pre>

      <p>
        Since Rust 1.75, this compiles as-is in many cases. But sometimes you need to
        return the future as a trait object, store it in a struct, or poll it yourself.
        That's when you run into:
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">fetch</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">Pin</span>&lt;<span class="ty">Box</span>&lt;<span class="kw">dyn</span> <span class="ty">Future</span>&lt;<span class="ty">Output</span> = <span class="ty">Vec</span>&lt;<span class="ty">u8</span>&gt;&gt; + <span class="ty">Send</span> + <span class="kw">'_</span>&gt;&gt;</code></pre>

      <p>
        What is <code>Pin</code>? Why is it needed? What does <code>Box::pin</code> do?
      </p>

      <h2>Why async needs <code>Pin</code></h2>

      <p>
        An <code>async fn</code> compiles to a state machine struct. Each <code>.await</code>
        point is a state. The struct holds the local variables that live across those
        <code>.await</code> points.
      </p>

      <pre><code><span class="kw">async fn</span> <span class="fn">example</span>() {
    <span class="kw">let</span> data = <span class="fn">vec!</span>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>];
    <span class="kw">let</span> slice = &amp;data[..];  <span class="cm">// reference to data</span>
    <span class="fn">some_async_op</span>().<span class="kw">await</span>;   <span class="cm">// suspend here</span>
    <span class="mac">println!</span>(<span class="str">"{:?}"</span>, slice); <span class="cm">// use slice after await</span>
}</code></pre>

      <p>
        The compiler-generated state machine holds both <code>data</code> and
        <code>slice</code>. But <code>slice</code> is a reference <em>into</em>
        <code>data</code> &mdash; it points to memory within the same struct. The struct
        contains a pointer to its own contents.
      </p>
      <p>
        If the struct moves in memory (e.g., from the stack to the heap, or when a
        <code>Vec</code> reallocates), <code>data</code> moves to a new address, but
        <code>slice</code> still points to the old address. The reference dangles.
      </p>
      <p>
        <code>Pin</code> solves this by guaranteeing: <strong>this value will not move in
        memory.</strong> Once a future is pinned, no one can move it, so self-references
        remain valid.
      </p>

      <h2>What <code>Pin</code> actually means</h2>

      <p>
        <code>Pin&lt;&amp;mut T&gt;</code> means: "you have a mutable reference to T, but
        you can't move T out of that spot." Normally, if you have <code>&amp;mut T</code>,
        you can call <code>std::mem::swap</code> or <code>std::mem::replace</code> to move
        the value somewhere else. <code>Pin</code> prevents that.
      </p>
      <p>
        Specifically, you can't get a <code>&amp;mut T</code> from a
        <code>Pin&lt;&amp;mut T&gt;</code> unless <code>T: Unpin</code>.
      </p>

      <h2><code>Unpin</code></h2>

      <p>
        Most types are <code>Unpin</code>. An <code>i32</code>, a <code>String</code>,
        a <code>Vec&lt;T&gt;</code> &mdash; none of them contain pointers into themselves,
        so moving them is perfectly safe. For these types, <code>Pin</code> does nothing.
      </p>
      <p>
        Futures generated by <code>async</code> blocks are <code>!Unpin</code> &mdash; they
        might contain pointers into themselves (like the <code>data</code>/<code>slice</code>
        example above). For these types, <code>Pin</code> matters: once pinned, they can't
        be moved.
      </p>

      <h2><code>Box::pin()</code></h2>

      <p>
        The easiest way to pin a future: put it on the heap.
      </p>

      <pre><code><span class="kw">use</span> std::pin::<span class="ty">Pin</span>;
<span class="kw">use</span> std::future::<span class="ty">Future</span>;

<span class="kw">fn</span> <span class="fn">fetch</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">Pin</span>&lt;<span class="ty">Box</span>&lt;<span class="kw">dyn</span> <span class="ty">Future</span>&lt;<span class="ty">Output</span> = <span class="ty">Vec</span>&lt;<span class="ty">u8</span>&gt;&gt; + <span class="ty">Send</span> + <span class="kw">'_</span>&gt;&gt; {
    <span class="ty">Box</span>::<span class="fn">pin</span>(<span class="kw">async move</span> {
        <span class="cm">// async implementation</span>
        <span class="fn">vec!</span>[]
    })
}</code></pre>

      <p>
        <code>Box::pin()</code> allocates the future on the heap and returns a
        <code>Pin&lt;Box&lt;...&gt;&gt;</code>. The <code>Box</code> pointer itself can
        move around, but the future it points to stays at the same address. Any pointers
        the future holds into its own data stay valid.
      </p>

      <h2>When you encounter <code>Pin</code></h2>

      <p>
        In practice, you'll encounter <code>Pin</code> in three situations:
      </p>
      <ol>
        <li><strong>Async trait methods</strong> that need dynamic dispatch &mdash; return
          <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code></li>
        <li><strong>Storing futures in structs</strong> &mdash; the struct field needs to
          be <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code></li>
        <li><strong>Manual <code>Future</code> implementations</strong> &mdash; the
          <code>poll</code> method takes <code>Pin&lt;&amp;mut Self&gt;</code></li>
      </ol>
      <p>
        For cases 1 and 2, <code>Box::pin()</code> is the answer. Case 3 is advanced and
        rarely needed in application code &mdash; libraries like <code>tokio</code> and
        <code>futures</code> handle it internally.
      </p>

      <h2>Native async traits</h2>

      <p>
        Since Rust 1.75, you can write <code>async fn</code> in traits directly. When the
        compiler knows the concrete future type at compile time, no boxing is needed. You
        still need boxing when you use <code>dyn Trait</code>, because the compiler can't
        know which type's future it will be.
      </p>

      <h2>When to use it</h2>

      <ul>
        <li>Returning futures from trait methods that use <code>dyn Trait</code></li>
        <li>Storing futures of different types in the same <code>Vec</code> or struct field</li>
        <li>Any situation where the compiler asks for <code>Pin</code></li>
      </ul>
      <p>
        For normal <code>async fn</code> usage, you never think about <code>Pin</code>.
        The compiler handles it. <code>Pin</code> only shows up when you use trait objects,
        implement <code>Future</code> by hand, or store different future types together.
      </p>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-interior-mutability.html">#1: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#2: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><a href="rust-patterns-cow.html">#6: Cow &mdash; Borrow or Own</a></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#7: Lifetime Annotations</a></li>
          <li><a href="rust-patterns-static-clone.html">#8: &rsquo;static + Clone</a></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-newtype.html">#11: Newtype</a></li>
          <li><a href="rust-patterns-typestate.html">#12: Typestate</a></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#16: Error Handling</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><strong>#19: Pin and Boxing Futures</strong></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
