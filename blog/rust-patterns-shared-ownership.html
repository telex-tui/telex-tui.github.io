<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #2: Shared Ownership - Telex</title>
  <meta name="description" content="When multiple parts of your program need to own the same data, Rust's single-ownership model needs extending. Rc provides reference-counted sharing.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #2: Shared Ownership</h1>
      <div class="post-meta">March 2026</div>
      <p class="series-nav">Post 2 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        In Rust, one variable owns each value, and when that variable goes out of scope, the
        value is dropped. That's how Rust avoids a garbage collector. But trees, graphs, and
        callback registries all need multiple parts of the program to hold onto the same
        data. Single ownership doesn't cover that.
      </p>

      <h2>The motivation</h2>

      <p>
        You're building a tree. Each node owns its children, but you also want a flat
        <code>Vec</code> of all nodes so you can iterate over them quickly. The tree owns the
        nodes through the parent-child chain. The flat <code>Vec</code> also needs to point to
        those same nodes.
      </p>

      <pre><code><span class="kw">struct</span> <span class="ty">Node</span> {
    value: <span class="ty">String</span>,
    children: <span class="ty">Vec</span>&lt;<span class="ty">Box</span>&lt;<span class="ty">Node</span>&gt;&gt;,
}

<span class="kw">fn</span> <span class="fn">main</span>() {
    <span class="kw">let</span> child = <span class="ty">Box</span>::<span class="fn">new</span>(<span class="ty">Node</span> {
        value: <span class="str">"child"</span>.<span class="fn">to_string</span>(),
        children: <span class="fn">vec!</span>[],
    });

    <span class="kw">let</span> <span class="kw">mut</span> all_nodes = <span class="fn">vec!</span>[child];  <span class="cm">// child moved here</span>

    <span class="kw">let</span> parent = <span class="ty">Node</span> {
        value: <span class="str">"parent"</span>.<span class="fn">to_string</span>(),
        children: <span class="fn">vec!</span>[child],          <span class="cm">// ERROR: use of moved value</span>
    };
}</code></pre>

      <p>
        The compiler:
      </p>

      <pre><code><span class="cm">error[E0382]: use of moved value: `child`</span></code></pre>

      <p>
        <code>child</code> was moved into <code>all_nodes</code>, so it's gone. You can't
        also put it in the parent's <code>children</code> vec. A <code>Box</code> has exactly
        one owner &mdash; when you move it, the original variable becomes unusable.
      </p>

      <h2>Why Rust does this</h2>

      <p>
        Because every value in Rust has exactly one owner, the drop point is statically
        determined &mdash; right when that owner goes out of scope. No double frees,
        no use-after-free, no garbage collector. <code>Box&lt;T&gt;</code> works exactly
        like this: one pointer, one owner, one deallocation.
      </p>
      <p>
        But sometimes multiple parts of your program need to point to the same data &mdash;
        a node that appears in both a tree and a flat list, a config struct read by
        multiple subsystems, a callback registered with several event sources. You can't
        do that if only one variable is allowed to own the value.
      </p>

      <h2>The pattern: <code>Rc&lt;T&gt;</code></h2>

      <p>
        <code>Rc&lt;T&gt;</code> is a pointer that counts how many clones of itself exist.
        Multiple <code>Rc</code>s can point to the same heap-allocated value. Each clone
        bumps the count up; each drop bumps it down. When the last one is dropped, the
        value is freed.
      </p>

      <pre><code><span class="kw">use</span> std::rc::<span class="ty">Rc</span>;

<span class="kw">struct</span> <span class="ty">Node</span> {
    value: <span class="ty">String</span>,
    children: <span class="ty">Vec</span>&lt;<span class="ty">Rc</span>&lt;<span class="ty">Node</span>&gt;&gt;,
}

<span class="kw">fn</span> <span class="fn">main</span>() {
    <span class="kw">let</span> child = <span class="ty">Rc</span>::<span class="fn">new</span>(<span class="ty">Node</span> {
        value: <span class="str">"child"</span>.<span class="fn">to_string</span>(),
        children: <span class="fn">vec!</span>[],
    });

    <span class="kw">let</span> <span class="kw">mut</span> all_nodes = <span class="fn">vec!</span>[<span class="ty">Rc</span>::<span class="fn">clone</span>(&amp;child)]; <span class="cm">// count: 2</span>

    <span class="kw">let</span> parent = <span class="ty">Node</span> {
        value: <span class="str">"parent"</span>.<span class="fn">to_string</span>(),
        children: <span class="fn">vec!</span>[<span class="ty">Rc</span>::<span class="fn">clone</span>(&amp;child)],  <span class="cm">// count: 3</span>
    };

    <span class="cm">// child, all_nodes[0], and parent.children[0]</span>
    <span class="cm">// all point to the same Node</span>
}</code></pre>

      <p>
        <code>Rc::clone(&amp;child)</code> doesn't copy the <code>Node</code>. It just bumps the
        reference count and hands back a new <code>Rc</code> pointing to the same allocation.
        That's cheap &mdash; it's an integer increment and a pointer copy.
      </p>

      <h2>The <code>Rc::clone()</code> convention</h2>

      <p>
        You'll see experienced Rust developers write <code>Rc::clone(&amp;x)</code> instead of
        <code>x.clone()</code>. Both do the same thing, but <code>Rc::clone</code> makes it
        visually obvious that you're bumping a reference count, not deep-copying data.
        When scanning code, <code>x.clone()</code> could be expensive (cloning a large struct);
        <code>Rc::clone(&amp;x)</code> is always cheap.
      </p>

      <h2>What you can't do</h2>

      <p>
        <code>Rc</code> only gives you <code>&amp;T</code> &mdash; you can read through it,
        but you can never get <code>&amp;mut T</code>. This makes sense: if multiple
        <code>Rc</code>s point to the same data and any of them could write to it, you'd
        have aliasing bugs. <code>Rc</code> avoids this by keeping the data read-only.
      </p>

      <pre><code><span class="kw">let</span> data = <span class="ty">Rc</span>::<span class="fn">new</span>(<span class="str">"hello"</span>.<span class="fn">to_string</span>());
<span class="kw">let</span> alias = <span class="ty">Rc</span>::<span class="fn">clone</span>(&amp;data);

<span class="cm">// Reading: fine</span>
<span class="mac">println!</span>(<span class="str">"{}"</span>, *data);

<span class="cm">// Mutating: no</span>
<span class="cm">// There's no way to get &amp;mut String from Rc&lt;String&gt;</span></code></pre>

      <p>
        If you need shared ownership <em>and</em> mutation, you need to combine
        <code>Rc</code> with <code>RefCell</code> &mdash;
        <a href="rust-patterns-rc-refcell.html">the next post</a>.
      </p>

      <h2>The tradeoffs</h2>

      <p>
        <code>Rc</code> has a small runtime cost: it bumps the count on every clone and drop.
        In practice this is negligible unless you're cloning in a tight loop.
      </p>
      <p>
        The bigger constraint: <code>Rc</code> is <strong>not thread-safe</strong>. Its
        count is a plain integer, not an atomic. Sending an <code>Rc</code> to another thread
        won't compile &mdash; <code>Rc</code> is <code>!Send</code>. For shared ownership
        across threads, use <code>Arc</code>
        (<a href="rust-patterns-arc-mutex.html">#17</a>), which uses atomic operations for
        the count.
      </p>
      <p>
        <code>Rc</code> also can't detect cycles. If A holds an <code>Rc</code> to B and B
        holds an <code>Rc</code> to A, the count never reaches zero and neither is ever
        freed. Break cycles with <code>Weak</code>, which points to the data without
        keeping it alive.
      </p>

      <h2>What does this cost?</h2>

      <p>
        <code>Rc</code> stores two <code>usize</code>s alongside your data on the heap: a strong
        count and a weak count. Cloning an <code>Rc</code> increments the strong count &mdash; a
        single non-atomic integer operation. Dropping decrements it. When the strong count reaches
        zero, the data is dropped; when the weak count also reaches zero, the allocation is freed.
        The cost is one heap allocation at creation and one integer bump per clone/drop. There is no
        atomic synchronization, which is why <code>Rc</code> is faster than <code>Arc</code> but
        restricted to a single thread. Without <code>Rc</code>, shared ownership on the heap would
        require <code>unsafe</code> &mdash; raw pointer aliasing with manual reference counting,
        exactly what <code>Rc</code> encapsulates.
      </p>

      <h2>When to use it</h2>

      <p>
        <strong>Good uses:</strong>
      </p>
      <ul>
        <li>Tree nodes that appear in both a parent's <code>children</code> vec and a flat index</li>
        <li>A config struct that multiple subsystems need to read</li>
        <li>A callback closure registered with several event sources</li>
        <li>Any time you need two or more variables to point to the same heap data</li>
      </ul>
      <p>
        <strong>When not to use it:</strong>
      </p>
      <ul>
        <li>If only one variable needs to own the data, use <code>Box</code> or just own it
          directly &mdash; simpler and no counting overhead</li>
        <li>If you need thread safety, use <code>Arc</code> instead</li>
        <li>If you need mutation, <code>Rc</code> alone isn't enough &mdash; combine it with
          <code>RefCell</code> (<a href="rust-patterns-rc-refcell.html">#3</a>)</li>
      </ul>

      <h2>What comes next</h2>

      <p>
        <code>Rc</code> lets multiple variables own the same data, but none of them can write
        to it. <code>RefCell</code>
        (<a href="rust-patterns-interior-mutability.html">#1</a>) lets you write through a
        shared reference, but only one variable can own the struct. The next post puts them
        together: <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> &mdash; multiple owners who can all
        read and write. This is the workhorse for single-threaded Rust, and it's exactly
        what Telex uses for component state.
      </p>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-interior-mutability.html">#1: Interior Mutability</a></li>
          <li><strong>#2: Shared Ownership</strong></li>
          <li><a href="rust-patterns-rc-refcell.html">#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><a href="rust-patterns-cow.html">#6: Cow &mdash; Borrow or Own</a></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#7: Lifetime Annotations</a></li>
          <li><a href="rust-patterns-static-clone.html">#8: &rsquo;static + Clone</a></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-newtype.html">#11: Newtype</a></li>
          <li><a href="rust-patterns-typestate.html">#12: Typestate</a></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#16: Error Handling</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#19: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
