<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust's _or Methods (and Five Other Naming Patterns) in Plain English - Telex</title>
  <meta name="description" content="Six naming conventions — _or/_or_else, as_/to_/into_, _map, _while, _by/_by_key, copied/cloned — that cover 80% of the standard library. Once they click, new methods become guessable.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust's <code>_or</code> Methods (and Five Other Naming Patterns) in Plain English</h1>
      <div class="post-meta">February 2026</div>

      <p>
        You open the standard library docs and see <code>unwrap_or</code>,
        <code>unwrap_or_else</code>, <code>unwrap_or_default</code>,
        <code>as_ref</code>, <code>to_owned</code>, <code>into_inner</code>,
        <code>filter_map</code>, <code>take_while</code>, <code>min_by_key</code>,
        <code>copied</code>, <code>cloned</code>. It looks like a mountain of
        unrelated methods. It isn't. Just six naming conventions cover roughly
        80% of the standard library. Once they click, methods you've never seen before become guessable.
      </p>

      <h2>1. <code>_or</code> vs <code>_or_else</code> -- eager value vs lazy closure</h2>

      <p>
        This is the most pervasive. Whenever you see a pair like this, the
        <code>_or</code> version takes a value you already have. The
        <code>_or_else</code> version takes a closure that computes the value on demand.
        Same pattern in <code>unwrap_or</code> / <code>unwrap_or_else</code>,
        <code>ok_or</code> / <code>ok_or_else</code>,
        <code>or</code> / <code>or_else</code>.
        Once you see it once, you see it everywhere.
      </p>

      <pre><code><span class="kw">let</span> a: <span class="ty">Option</span>&lt;<span class="ty">i32</span>&gt; = <span class="ty">None</span>;

<span class="cm">// _or: you already have the fallback value</span>
<span class="kw">let</span> x = a.<span class="fn">unwrap_or</span>(<span class="num">42</span>);

<span class="cm">// _or_else: compute the fallback only if needed</span>
<span class="kw">let</span> y = a.<span class="fn">unwrap_or_else</span>(|| <span class="fn">expensive_default</span>());</code></pre>

      <p>
        The same pairs appear across <code>Option</code> and <code>Result</code>:
      </p>

      <pre><code><span class="cm">// Option</span>
<span class="fn">unwrap_or</span>(val)       / <span class="fn">unwrap_or_else</span>(|| ...)
<span class="fn">or</span>(other_option)     / <span class="fn">or_else</span>(|| ...)

<span class="cm">// Result</span>
<span class="fn">unwrap_or</span>(val)       / <span class="fn">unwrap_or_else</span>(|err| ...)
<span class="fn">ok_or</span>(err)           / <span class="fn">ok_or_else</span>(|| ...)
<span class="fn">or</span>(other_result)     / <span class="fn">or_else</span>(|err| ...)</code></pre>

      <p>
        Why bother with the closure version? Because the value in <code>_or</code>
        is always evaluated, even when it isn't needed. If creating the fallback is
        expensive -- a heap allocation, a database lookup, a computation --
        <code>_or_else</code> avoids the work when the <code>Option</code> is
        <code>Some</code> or the <code>Result</code> is <code>Ok</code>.
      </p>

      <pre><code><span class="cm">// This allocates a String every time, even when config has a value:</span>
<span class="kw">let</span> name = config.<span class="fn">unwrap_or</span>(<span class="ty">String</span>::<span class="fn">from</span>(<span class="str">"default"</span>));

<span class="cm">// This only allocates when config is None:</span>
<span class="kw">let</span> name = config.<span class="fn">unwrap_or_else</span>(|| <span class="ty">String</span>::<span class="fn">from</span>(<span class="str">"default"</span>));</code></pre>

      <h2>2. <code>as_</code> vs <code>to_</code> vs <code>into_</code> -- how much work is being done</h2>

      <p>
        This tells you the cost and the ownership story at a glance:
      </p>

      <ul>
        <li><code>as_</code> -- a cheap borrow. Just a different view of the same
          thing. No allocation, no cloning. Think: <em>peeking</em>.</li>
        <li><code>to_</code> -- creates something new but leaves the original
          alone. Usually involves allocation or conversion. Think:
          <em>photocopying</em>.</li>
        <li><code>into_</code> -- consumes the original and transforms it. The
          original is gone. Think: <em>metamorphosing</em>.</li>
      </ul>

      <pre><code><span class="kw">let</span> s = <span class="ty">String</span>::<span class="fn">from</span>(<span class="str">"hello"</span>);

<span class="cm">// as_ -- borrows, cheap, returns a reference</span>
<span class="kw">let</span> bytes: &amp;[<span class="ty">u8</span>] = s.<span class="fn">as_bytes</span>();   <span class="cm">// &amp;String -&gt; &amp;[u8], no copy</span>
<span class="kw">let</span> slice: &amp;<span class="ty">str</span> = s.<span class="fn">as_str</span>();     <span class="cm">// &amp;String -&gt; &amp;str, no copy</span>

<span class="cm">// to_ -- copies/converts, original untouched</span>
<span class="kw">let</span> upper: <span class="ty">String</span> = s.<span class="fn">to_uppercase</span>();  <span class="cm">// creates a new String</span>
<span class="kw">let</span> owned: <span class="ty">String</span> = <span class="str">"hi"</span>.<span class="fn">to_owned</span>();   <span class="cm">// &amp;str -&gt; String, allocates</span>

<span class="cm">// into_ -- consumes, original is gone</span>
<span class="kw">let</span> bytes: <span class="ty">Vec</span>&lt;<span class="ty">u8</span>&gt; = s.<span class="fn">into_bytes</span>(); <span class="cm">// String consumed, Vec reuses its buffer</span>
<span class="cm">// println!("{s}");                      // ERROR: s has been moved</span></code></pre>

      <p>
        <code>as_</code> is O(1) and virtually free. <code>to_</code> usually
        allocates. <code>into_</code> is often more efficient than
        <code>to_</code> because it can reuse the existing buffer instead of
        copying it.
      </p>

      <p>
        The pattern repeats across the standard library:
      </p>

      <pre><code><span class="ty">Path</span>::<span class="fn">as_os_str</span>()        <span class="cm">// borrow: &amp;Path -&gt; &amp;OsStr</span>
<span class="ty">Path</span>::<span class="fn">to_path_buf</span>()      <span class="cm">// copy:   &amp;Path -&gt; PathBuf</span>
<span class="ty">PathBuf</span>::<span class="fn">into_os_string</span>() <span class="cm">// move:   PathBuf -&gt; OsString</span>

<span class="ty">OsStr</span>::<span class="fn">as_encoded_bytes</span>() <span class="cm">// borrow</span>
<span class="ty">OsStr</span>::<span class="fn">to_os_string</span>()     <span class="cm">// copy</span>
<span class="ty">OsString</span>::<span class="fn">into_string</span>()   <span class="cm">// move</span></code></pre>

      <h2>3. <code>_map</code> as a combiner -- two operations in one pass</h2>

      <p>
        When a method ends in <code>_map</code>, it performs a transformation
        as part of another operation. The second word is always
        <code>map</code> because mapping is the universal glue operation:
      </p>

      <pre><code><span class="kw">let</span> v = <span class="kw">vec!</span>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>];

<span class="cm">// filter_map = filter + map in one step</span>
<span class="cm">// Return Some(value) to keep, None to discard</span>
<span class="kw">let</span> evens_doubled: <span class="ty">Vec</span>&lt;<span class="ty">i32</span>&gt; = v.<span class="fn">iter</span>()
    .<span class="fn">filter_map</span>(|&amp;x| <span class="kw">if</span> x % <span class="num">2</span> == <span class="num">0</span> { <span class="ty">Some</span>(x * <span class="num">2</span>) } <span class="kw">else</span> { <span class="ty">None</span> })
    .<span class="fn">collect</span>();
<span class="cm">// [4, 8]</span>

<span class="cm">// find_map = find + map -- find the first match and transform it</span>
<span class="kw">let</span> first_even_squared: <span class="ty">Option</span>&lt;<span class="ty">i32</span>&gt; = v.<span class="fn">iter</span>()
    .<span class="fn">find_map</span>(|&amp;x| <span class="kw">if</span> x % <span class="num">2</span> == <span class="num">0</span> { <span class="ty">Some</span>(x * x) } <span class="kw">else</span> { <span class="ty">None</span> });
<span class="cm">// Some(4)</span>

<span class="cm">// flat_map = map + flatten -- map each element to an iterator, then flatten</span>
<span class="kw">let</span> words = <span class="kw">vec!</span>[<span class="str">"hello world"</span>, <span class="str">"foo bar"</span>];
<span class="kw">let</span> all: <span class="ty">Vec</span>&lt;&amp;<span class="ty">str</span>&gt; = words.<span class="fn">iter</span>()
    .<span class="fn">flat_map</span>(|s| s.<span class="fn">split_whitespace</span>())
    .<span class="fn">collect</span>();
<span class="cm">// ["hello", "world", "foo", "bar"]</span></code></pre>

      <p>
        The pattern works on <code>Option</code> and <code>Result</code> too,
        not just iterators:
      </p>

      <pre><code><span class="kw">let</span> maybe_str: <span class="ty">Option</span>&lt;&amp;<span class="ty">str</span>&gt; = <span class="ty">Some</span>(<span class="str">"42"</span>);

<span class="cm">// and_then is Option's version of flat_map:</span>
<span class="cm">// map would give Option&lt;Result&gt;, and_then flattens to Option</span>
<span class="kw">let</span> parsed: <span class="ty">Option</span>&lt;<span class="ty">i32</span>&gt; = maybe_str.<span class="fn">and_then</span>(|s| s.<span class="fn">parse</span>().<span class="fn">ok</span>());</code></pre>

      <h2>4. <code>_while</code> adds a predicate</h2>

      <p>
        The base method takes a count. The <code>_while</code> variant takes a
        condition instead. <code>take</code> takes a count,
        <code>take_while</code> takes a condition. Same for <code>skip</code>
        vs <code>skip_while</code>:
      </p>

      <pre><code><span class="kw">let</span> v = <span class="kw">vec!</span>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>];

<span class="cm">// take(n) -- take exactly n elements</span>
<span class="kw">let</span> first_three: <span class="ty">Vec</span>&lt;&amp;<span class="ty">i32</span>&gt; = v.<span class="fn">iter</span>().<span class="fn">take</span>(<span class="num">3</span>).<span class="fn">collect</span>();
<span class="cm">// [1, 2, 3]</span>

<span class="cm">// take_while(predicate) -- take while condition holds</span>
<span class="kw">let</span> small: <span class="ty">Vec</span>&lt;&amp;<span class="ty">i32</span>&gt; = v.<span class="fn">iter</span>().<span class="fn">take_while</span>(|&amp;&amp;x| x &lt; <span class="num">4</span>).<span class="fn">collect</span>();
<span class="cm">// [1, 2, 3]</span>

<span class="cm">// skip(n) -- skip exactly n elements</span>
<span class="kw">let</span> after_two: <span class="ty">Vec</span>&lt;&amp;<span class="ty">i32</span>&gt; = v.<span class="fn">iter</span>().<span class="fn">skip</span>(<span class="num">2</span>).<span class="fn">collect</span>();
<span class="cm">// [3, 4, 5]</span>

<span class="cm">// skip_while(predicate) -- skip while condition holds</span>
<span class="kw">let</span> from_three: <span class="ty">Vec</span>&lt;&amp;<span class="ty">i32</span>&gt; = v.<span class="fn">iter</span>().<span class="fn">skip_while</span>(|&amp;&amp;x| x &lt; <span class="num">3</span>).<span class="fn">collect</span>();
<span class="cm">// [3, 4, 5]</span></code></pre>

      <p>
        The pattern is consistent: the base version works with a fixed count,
        <code>_while</code> makes it dynamic. Crucially, these are
        short-circuiting: they stop as soon as the condition returns
        <code>false</code> and will not process subsequent elements.
      </p>

      <h2>5. <code>_by</code> / <code>_by_key</code> -- "by what measure?"</h2>

      <p>
        The base method uses natural ordering (<code>Ord</code>). The
        <code>_by</code> variant lets you supply a custom comparator. The
        <code>_by_key</code> variant lets you say "compare by this extracted
        value":
      </p>

      <pre><code><span class="kw">let</span> words = <span class="kw">vec!</span>[<span class="str">"cherry"</span>, <span class="str">"fig"</span>, <span class="str">"apple"</span>, <span class="str">"date"</span>];

<span class="cm">// min() -- natural ordering (alphabetical for strings)</span>
<span class="kw">let</span> first = words.<span class="fn">iter</span>().<span class="fn">min</span>();
<span class="cm">// Some("apple")</span>

<span class="cm">// min_by -- custom comparator</span>
<span class="kw">let</span> shortest = words.<span class="fn">iter</span>()
    .<span class="fn">min_by</span>(|a, b| a.<span class="fn">len</span>().<span class="fn">cmp</span>(&amp;b.<span class="fn">len</span>()));
<span class="cm">// Some("fig")</span>

<span class="cm">// min_by_key -- compare by extracted key (simpler when you can)</span>
<span class="kw">let</span> shortest = words.<span class="fn">iter</span>()
    .<span class="fn">min_by_key</span>(|w| w.<span class="fn">len</span>());
<span class="cm">// Some("fig")</span></code></pre>

      <p>
        The same trio appears for <code>max</code>, <code>sort</code>, and
        others:
      </p>

      <pre><code><span class="cm">// Sorting</span>
v.<span class="fn">sort</span>();                          <span class="cm">// natural order</span>
v.<span class="fn">sort_by</span>(|a, b| b.<span class="fn">cmp</span>(a));        <span class="cm">// custom comparator (here: reverse)</span>
v.<span class="fn">sort_by_key</span>(|item| item.score);   <span class="cm">// compare by extracted field</span>

<span class="cm">// Max</span>
v.<span class="fn">iter</span>().<span class="fn">max</span>();                     <span class="cm">// natural order</span>
v.<span class="fn">iter</span>().<span class="fn">max_by</span>(|a, b| ...);       <span class="cm">// custom comparator</span>
v.<span class="fn">iter</span>().<span class="fn">max_by_key</span>(|x| ...);      <span class="cm">// compare by extracted key</span></code></pre>

      <p>
        Use <code>_by_key</code> for comparing a single property or derived
        value. Use <code>_by</code> for complex logic, such as multi-field
        tie-breaking or custom sort orders.
      </p>

      <h2>6. <code>copied</code> vs <code>cloned</code> -- how expensive is the copy?</h2>

      <p>
        Both do the same thing: turn an iterator of references into an iterator
        of owned values. Same idea (get an owned value from a reference), but
        <code>copied</code> is for small cheap types and <code>cloned</code> is
        for anything:
      </p>

      <pre><code><span class="kw">let</span> v = <span class="kw">vec!</span>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>];

<span class="cm">// copied -- requires T: Copy (small, cheap types: integers, bools, floats)</span>
<span class="kw">let</span> owned: <span class="ty">Vec</span>&lt;<span class="ty">i32</span>&gt; = v.<span class="fn">iter</span>().<span class="fn">copied</span>().<span class="fn">collect</span>();

<span class="cm">// cloned -- requires T: Clone (anything, but might be expensive)</span>
<span class="kw">let</span> owned: <span class="ty">Vec</span>&lt;<span class="ty">i32</span>&gt; = v.<span class="fn">iter</span>().<span class="fn">cloned</span>().<span class="fn">collect</span>();</code></pre>

      <p>
        Both work here because integers implement both <code>Copy</code> and
        <code>Clone</code>. The difference matters for intent and guarantees:
      </p>

      <pre><code><span class="kw">let</span> strings = <span class="kw">vec!</span>[<span class="ty">String</span>::<span class="fn">from</span>(<span class="str">"a"</span>), <span class="ty">String</span>::<span class="fn">from</span>(<span class="str">"b"</span>)];

<span class="cm">// strings.iter().copied()  -- WON'T COMPILE: String isn't Copy</span>
<span class="kw">let</span> owned: <span class="ty">Vec</span>&lt;<span class="ty">String</span>&gt; = strings.<span class="fn">iter</span>().<span class="fn">cloned</span>().<span class="fn">collect</span>(); <span class="cm">// works</span></code></pre>

      <p>
        If it compiles with <code>copied</code>, prefer it. It signals to the
        reader that the copy is trivial -- a memcpy of a few bytes, not a heap
        allocation. When you see <code>cloned</code>, you know something more
        expensive might be happening.
      </p>

      <h2>Putting it all together</h2>

      <p>
        These six conventions are composable. You can predict method names you've
        never seen:
      </p>

      <ul>
        <li><code>ok_or_else</code> -- converts <code>Option</code> to
          <code>Result</code>, computing the error lazily
          (<code>_or_else</code> = closure)</li>
        <li><code>into_keys</code> -- consumes a <code>HashMap</code> and gives
          you owned keys (<code>into_</code> = consuming)</li>
        <li><code>max_by_key</code> -- finds the maximum by an extracted value
          (<code>_by_key</code> = extracted comparison)</li>
        <li><code>to_ascii_uppercase</code> -- creates a new value, leaves the
          original (<code>to_</code> = new allocation)</li>
      </ul>

      <p>
        When you encounter a new type in the standard library, you can often guess
        what methods it has. Does it have <code>as_ref</code>? Probably. Does it
        have <code>into_inner</code>? If it wraps something, yes. Does the
        iterator adapter have a <code>_by_key</code> variant? Check, but likely.
      </p>

      <p>
        The naming isn't arbitrary. It's a system. Learn these six meta-patterns
        and the standard library stops feeling like a phone book and starts
        feeling like a language you can read.
      </p>

    </article>
  </main>

  <footer>
    <div class="container">
      MIT - Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
