<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #3: Rc RefCell - Telex</title>
  <meta name="description" content="Rc for sharing, RefCell for mutation — together they solve the shared mutable state problem in single-threaded Rust. A legitimate pattern, not a code smell.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</h1>
      <div class="post-meta">March 2026</div>
      <p class="series-nav">Post 3 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        <a href="rust-patterns-interior-mutability.html">Post #1</a> gave you interior
        mutability: changing data behind a shared reference.
        <a href="rust-patterns-shared-ownership.html">Post #2</a> gave you shared ownership:
        multiple handles to the same data. Now put them together. You have a tree of UI
        components where every node is shared (multiple parents, siblings, or event handlers
        hold references). Some of those nodes need to update their state &mdash; a text field
        stores what the user typed, a counter increments. You need both shared ownership
        (<code>Rc</code>) and the ability to mutate through shared references
        (<code>RefCell</code>). <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> is the combination
        that makes this work.
      </p>

      <h2>The motivation</h2>

      <p>
        You have a <code>Subject</code> struct that holds a value, and several observers that
        need to read and change that value. Each observer needs its own handle to the
        subject &mdash; you can't pass a single <code>&amp;mut</code> to all of them.
      </p>

      <pre><code><span class="kw">use</span> std::rc::<span class="ty">Rc</span>;

<span class="kw">struct</span> <span class="ty">Subject</span> {
    value: <span class="ty">i32</span>,
}

<span class="kw">fn</span> <span class="fn">main</span>() {
    <span class="kw">let</span> subject = <span class="ty">Rc</span>::<span class="fn">new</span>(<span class="ty">Subject</span> { value: <span class="num">0</span> });

    <span class="kw">let</span> observer_a = <span class="ty">Rc</span>::<span class="fn">clone</span>(&amp;subject);
    <span class="kw">let</span> observer_b = <span class="ty">Rc</span>::<span class="fn">clone</span>(&amp;subject);

    <span class="cm">// Both observers can read the value</span>
    <span class="mac">println!</span>(<span class="str">"{}"</span>, observer_a.value);

    <span class="cm">// But neither can modify it — Rc gives &amp;T, never &amp;mut T</span>
}</code></pre>

      <p>
        <code>Rc</code> lets both observers point to the same <code>Subject</code>, but
        neither can write to it. And <code>RefCell</code> alone wouldn't help &mdash; it
        lets you write, but only one variable can own it. You need both.
      </p>

      <h2>The pattern: <code>Rc&lt;RefCell&lt;T&gt;&gt;</code></h2>

      <p>
        Put the data in a <code>RefCell</code> so you can write to it, then put that in an
        <code>Rc</code> so multiple variables can own it. Each owner clones the
        <code>Rc</code>. When they need to write, they call <code>.borrow_mut()</code> on
        the <code>RefCell</code> inside.
      </p>

      <pre><code><span class="kw">use</span> std::cell::<span class="ty">RefCell</span>;
<span class="kw">use</span> std::rc::<span class="ty">Rc</span>;

<span class="kw">struct</span> <span class="ty">Subject</span> {
    value: <span class="ty">i32</span>,
}

<span class="kw">fn</span> <span class="fn">main</span>() {
    <span class="kw">let</span> subject = <span class="ty">Rc</span>::<span class="fn">new</span>(<span class="ty">RefCell</span>::<span class="fn">new</span>(<span class="ty">Subject</span> { value: <span class="num">0</span> }));

    <span class="kw">let</span> observer_a = <span class="ty">Rc</span>::<span class="fn">clone</span>(&amp;subject);
    <span class="kw">let</span> observer_b = <span class="ty">Rc</span>::<span class="fn">clone</span>(&amp;subject);

    <span class="cm">// Observer A increments</span>
    observer_a.<span class="fn">borrow_mut</span>().value += <span class="num">1</span>;

    <span class="cm">// Observer B reads the updated value</span>
    <span class="mac">println!</span>(<span class="str">"{}"</span>, observer_b.<span class="fn">borrow</span>().value); <span class="cm">// 1</span>

    <span class="cm">// Observer B also mutates</span>
    observer_b.<span class="fn">borrow_mut</span>().value += <span class="num">10</span>;

    <span class="cm">// Observer A sees the change</span>
    <span class="mac">println!</span>(<span class="str">"{}"</span>, observer_a.<span class="fn">borrow</span>().value); <span class="cm">// 11</span>
}</code></pre>

      <p>
        <code>Rc</code> handles the sharing. <code>RefCell</code> handles the writing.
        Together they let multiple variables own and modify the same data, on a single thread.
      </p>

      <h2>Memory layout</h2>

      <p>
        An <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> creates two layers of indirection.
        The <code>Rc</code> allocates a block on the heap containing: the strong count
        (<code>usize</code>), the weak count (<code>usize</code>), and the inner value &mdash;
        which is a <code>RefCell&lt;T&gt;</code>. The <code>RefCell</code> itself adds an
        <code>isize</code> borrow flag in front of your <code>T</code>. So the heap layout
        is roughly: <code>[strong_count | weak_count | borrow_flag | T]</code>. Accessing
        <code>T</code> means following the <code>Rc</code> pointer to the heap block, skipping
        past the counts, then checking the borrow flag. That's one pointer chase and one branch.
        In cache terms, the entire <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> fits in a single
        cache line for small <code>T</code>. For large <code>T</code> or many <code>Rc</code>
        clones spread across code, each dereference is a potential L1 miss. This matters in
        tight loops &mdash; if you're iterating millions of
        <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> values, consider index-based design
        (<a href="rust-patterns-index-based-design.html">#5</a>) instead.
      </p>

      <h2>"Is this a code smell?"</h2>

      <p>
        No. This comes up often enough that it deserves a direct answer. If you search for
        <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> online, you'll find people calling it an
        antipattern or saying it "fights the borrow checker." That's wrong.
      </p>
      <p>
        In garbage-collected languages, every heap object already works this way &mdash;
        multiple variables can point to it, any of them can write to it, and the runtime
        frees it when nobody points to it anymore. Rust just makes you spell it out. The
        pattern isn't fighting the borrow checker; it's the normal way to let multiple
        owners read and write the same data when safety can't be verified statically.
      </p>
      <p>
        UI frameworks, observer patterns, graph structures, callback registries &mdash; all
        of these need multiple owners with write access.
        <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> is how idiomatic Rust does it.
      </p>

      <h2>In practice: Telex's <code>State&lt;T&gt;</code></h2>

      <p>
        Telex wraps this in a clean API. Under the hood, <code>State&lt;T&gt;</code>
        is an <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> with convenience methods:
      </p>

      <pre><code><span class="kw">pub struct</span> <span class="ty">State</span>&lt;<span class="ty">T</span>&gt; {
    inner: <span class="ty">Rc</span>&lt;<span class="ty">StateInner</span>&lt;<span class="ty">T</span>&gt;&gt;,
}

<span class="cm">// Users write this:</span>
<span class="kw">let</span> count = <span class="ty">State</span>::<span class="fn">new</span>(<span class="num">0</span>);
<span class="mac">println!</span>(<span class="str">"{}"</span>, count.<span class="fn">get</span>());      <span class="cm">// 0</span>
count.<span class="fn">update</span>(|n| *n += <span class="num">1</span>);
<span class="mac">println!</span>(<span class="str">"{}"</span>, count.<span class="fn">get</span>());      <span class="cm">// 1</span></code></pre>

      <p>
        <code>State::new</code> creates the <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>.
        <code>.get()</code> calls <code>.borrow()</code> and clones the value.
        <code>.update()</code> calls <code>.borrow_mut()</code> and applies the closure.
        The <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> is invisible to the component author.
        See <a href="designing-a-tui-framework-in-rust.html">Designing a TUI Framework
        &mdash; Part 1</a> for the full story.
      </p>

      <h2>The common pitfall: overlapping borrows</h2>

      <p>
        <code>RefCell</code> panics if you break the borrow rules at runtime. The most
        common way to trigger this is holding a <code>.borrow_mut()</code> guard while
        something else tries to borrow the same <code>RefCell</code>.
      </p>

      <pre><code><span class="kw">let</span> data = <span class="ty">Rc</span>::<span class="fn">new</span>(<span class="ty">RefCell</span>::<span class="fn">new</span>(<span class="fn">vec!</span>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]));

<span class="cm">// BAD: borrow_mut lives too long</span>
<span class="kw">let</span> <span class="kw">mut</span> guard = data.<span class="fn">borrow_mut</span>();
guard.<span class="fn">push</span>(<span class="num">4</span>);
<span class="mac">println!</span>(<span class="str">"{}"</span>, data.<span class="fn">borrow</span>().<span class="fn">len</span>()); <span class="cm">// PANIC: already mutably borrowed</span></code></pre>

      <p>
        The fix: make sure the mutable borrow guard is dropped before you borrow again.
      </p>

      <pre><code><span class="kw">let</span> data = <span class="ty">Rc</span>::<span class="fn">new</span>(<span class="ty">RefCell</span>::<span class="fn">new</span>(<span class="fn">vec!</span>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]));

<span class="cm">// GOOD: borrow_mut is scoped</span>
{
    data.<span class="fn">borrow_mut</span>().<span class="fn">push</span>(<span class="num">4</span>);
} <span class="cm">// mutable borrow dropped here</span>

<span class="mac">println!</span>(<span class="str">"{}"</span>, data.<span class="fn">borrow</span>().<span class="fn">len</span>()); <span class="cm">// 4 — works</span></code></pre>

      <p>
        This is the main thing <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> asks of you: keep
        borrow guards short-lived. Borrow, do the work, let the guard drop. Don't hold
        a guard across a function call or callback that might borrow the same
        <code>RefCell</code>.
      </p>

      <h2>What does this cost?</h2>

      <p>
        You pay for <code>Rc</code>'s reference counting (one <code>usize</code> increment per
        clone, one decrement per drop &mdash; both non-atomic) plus <code>RefCell</code>'s borrow
        checking (one <code>isize</code> check per borrow, one branch). The heap allocation happens
        once at <code>Rc::new()</code>. Clones are cheap &mdash; pointer copy plus count bump. The
        combined overhead is small for typical use. In a garbage-collected language, every heap
        object already carries this overhead invisibly; Rust makes you opt in. Without
        <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>, you would need <code>unsafe</code> &mdash; either
        raw pointers with manual reference counting and manual borrow discipline, or an
        <code>UnsafeCell</code> with your own aliasing protocol.
        <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> is that protocol, proven correct by the standard
        library.
      </p>

      <h2>When to use it</h2>

      <p>
        <strong>Good uses:</strong>
      </p>
      <ul>
        <li>UI component state &mdash; exactly what Telex does</li>
        <li>Observer/subscriber setups where callbacks write to shared data</li>
        <li>A <code>HashMap</code> cache that multiple components read from and write to</li>
        <li>Graph nodes pointed to from multiple places that also need to be modified</li>
      </ul>
      <p>
        <strong>When not to use it:</strong>
      </p>
      <ul>
        <li>Across threads &mdash; use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>
          (<a href="rust-patterns-arc-mutex.html">#17</a>) instead</li>
        <li>When you can use <code>&amp;mut self</code> methods and pass ownership clearly
          &mdash; static verification is always preferable</li>
        <li>In tight loops where even the cost of bumping a reference count matters &mdash;
          consider storing indices into a <code>Vec</code>
          (<a href="rust-patterns-index-based-design.html">#5</a>) instead</li>
      </ul>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-interior-mutability.html">#1: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#2: Shared Ownership</a></li>
          <li><strong>#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</strong></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><a href="rust-patterns-cow.html">#6: Cow &mdash; Borrow or Own</a></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#7: Lifetime Annotations</a></li>
          <li><a href="rust-patterns-static-clone.html">#8: &rsquo;static + Clone</a></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-newtype.html">#11: Newtype</a></li>
          <li><a href="rust-patterns-typestate.html">#12: Typestate</a></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#16: Error Handling</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#19: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
