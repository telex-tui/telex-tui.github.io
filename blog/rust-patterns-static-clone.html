<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #8: 'static + Clone - Telex</title>
  <meta name="description" content="When lifetime annotations fight you in async or threaded code, cloning the data and owning it outright is often the correct solution. Profile before you optimise.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #8: <code>'static</code> + Clone &mdash; The Escape Hatch</h1>
      <div class="post-meta">May 2026</div>
      <p class="series-nav">Post 8 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        When you spawn a thread or an async task, it might run for a millisecond or for the
        rest of the program &mdash; there's no way to know. If that task borrows data from
        the function that created it, and the function returns before the task finishes, the
        borrowed data is gone and the task has a dangling reference. Rust prevents this at
        compile time: spawning APIs require <code>'static</code>, meaning the task must own
        everything it uses. Nothing borrowed, nothing that could disappear. The simplest way
        to satisfy this: clone the data so the task has its own copy, then move that copy in.
      </p>

      <h2>The motivation</h2>

      <pre><code><span class="kw">fn</span> <span class="fn">process</span>(data: &amp;<span class="ty">str</span>) {
    std::thread::<span class="fn">spawn</span>(|| {
        <span class="mac">println!</span>(<span class="str">"{}"</span>, data);
    });
}</code></pre>

      <pre><code><span class="cm">error[E0373]: closure may outlive the current function,
              but it borrows `data`, which is owned by the current function</span></code></pre>

      <p>
        <code>thread::spawn</code> requires the closure to be <code>'static</code> &mdash;
        it can't borrow from the function that created it, because the thread might keep
        running after that function returns. The same goes for <code>tokio::spawn</code>,
        <code>rayon::spawn</code>, and any API that takes
        <code>F: FnOnce() + Send + 'static</code>.
      </p>

      <h2>Why everything wants <code>'static</code></h2>

      <p>
        A spawned thread or task could finish instantly or run until the program exits &mdash;
        there's no way to know. So the runtime can't guarantee that borrowed data will still
        exist when the task tries to read it. <code>'static</code> means "this value is
        self-contained &mdash; it owns everything it needs." Nothing can dangle.
      </p>
      <p>
        Any owned type qualifies: <code>String</code>, <code>Vec&lt;u8&gt;</code>,
        <code>i32</code>, <code>PathBuf</code>. They're all <code>'static</code> because
        they don't borrow from anything else. The <code>'static</code> bound isn't asking
        for data that lives forever &mdash; it's asking for data that doesn't depend on
        someone else staying alive.
      </p>

      <h2>The pattern: clone and move</h2>

      <pre><code><span class="kw">fn</span> <span class="fn">process</span>(data: &amp;<span class="ty">str</span>) {
    <span class="kw">let</span> data = data.<span class="fn">to_string</span>(); <span class="cm">// owned copy</span>
    std::thread::<span class="fn">spawn</span>(<span class="kw">move</span> || {
        <span class="mac">println!</span>(<span class="str">"{}"</span>, data);
    });
}</code></pre>

      <p>
        <code>data.to_string()</code> creates an owned <code>String</code>.
        The <code>move</code> closure takes ownership of that <code>String</code>, so the
        closure is now <code>'static</code> &mdash; it owns everything inside it. No
        lifetime problems.
      </p>
      <p>
        For structs with multiple fields:
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">spawn_worker</span>(config: &amp;<span class="ty">Config</span>) {
    <span class="kw">let</span> config = config.<span class="fn">clone</span>();
    tokio::<span class="fn">spawn</span>(<span class="kw">async move</span> {
        <span class="cm">// config is owned — no lifetime constraints</span>
        <span class="fn">do_work</span>(&amp;config).<span class="kw">await</span>;
    });
}</code></pre>

      <h2>"But cloning is wasteful!"</h2>

      <p>
        This is the most common objection, and it's almost always premature. Think about
        what a clone actually does:
      </p>
      <ul>
        <li>Cloning a <code>String</code>: one heap allocation and a <code>memcpy</code>
          of the bytes</li>
        <li>Cloning a <code>Vec&lt;T&gt;</code>: one heap allocation and either a
          <code>memcpy</code> (for <code>Copy</code> types) or cloning each element</li>
        <li>Cloning a small struct with a few <code>String</code> fields: a handful of
          allocations</li>
      </ul>
      <p>
        Now think about context. If you're spawning a task to make a network request
        (milliseconds), query a database (milliseconds), or do any I/O at all, the clone
        takes nanoseconds. You literally can't measure it against the rest of the work.
        The worry about cloning is almost never justified.
      </p>
      <p>
        <strong>Profile before you optimise.</strong> If your profiler shows cloning is a
        bottleneck, fix it then. Until then, clone freely.
      </p>

      <h2><code>Arc</code> as a middle ground</h2>

      <p>
        When the data is genuinely large &mdash; megabytes, or cloned thousands of times per
        second &mdash; cloning might actually show up in your profiler. In that case, share
        the data instead of copying it:
      </p>

      <pre><code><span class="kw">use</span> std::sync::<span class="ty">Arc</span>;

<span class="kw">fn</span> <span class="fn">spawn_workers</span>(data: <span class="ty">Arc</span>&lt;<span class="ty">LargeDataset</span>&gt;) {
    <span class="kw">for</span> _ <span class="kw">in</span> <span class="num">0</span>..<span class="num">10</span> {
        <span class="kw">let</span> data = <span class="ty">Arc</span>::<span class="fn">clone</span>(&amp;data);
        tokio::<span class="fn">spawn</span>(<span class="kw">async move</span> {
            <span class="fn">process</span>(&amp;data).<span class="kw">await</span>;
        });
    }
}</code></pre>

      <p>
        <code>Arc::clone</code> just bumps a reference count &mdash; one atomic operation,
        no copying. All ten tasks read from the same <code>LargeDataset</code> on the heap.
        <code>Arc&lt;T&gt;</code> is <code>'static</code> and <code>Send</code> (when
        <code>T: Send + Sync</code>), so it satisfies the spawn bounds.
      </p>

      <h2>The decision tree</h2>

      <ol>
        <li>Does the task need <code>'static</code>? If the data is already owned, you're
          done &mdash; just <code>move</code> it in.</li>
        <li>Is the data small or the clone infrequent? <strong>Clone it.</strong> This
          is the right answer 90% of the time.</li>
        <li>Is the data large and shared by many tasks? Use <code>Arc</code>.</li>
        <li>Does the data need to be mutated by multiple tasks? Use
          <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>
          (<a href="rust-patterns-arc-mutex.html">#17</a>).</li>
      </ol>

      <h2>What does this cost?</h2>

      <p>
        A clone costs whatever the type's <code>Clone</code> implementation does:
        for <code>String</code>, one heap allocation and a <code>memcpy</code>;
        for <code>Arc</code>, one atomic increment (no data copy); for
        <code>i32</code>, nothing (it's <code>Copy</code>). The
        <code>'static</code> bound itself costs nothing — it's a compile-time
        constraint, not a runtime check. Moving a value into a <code>move</code>
        closure is also free — it's a bitwise copy of the value's stack
        representation, with no allocation. The only runtime cost in the "clone and
        move" pattern is the clone itself. In the common case (cloning a small struct
        before spawning a task that does milliseconds of I/O), the clone is
        unmeasurable noise.
      </p>

      <h2>When to use it</h2>

      <ul>
        <li>Spawning threads or async tasks that need data from the calling scope</li>
        <li>Callbacks that outlive the scope where they were created</li>
        <li>Any time the compiler demands <code>'static</code> and your data borrows from
          something</li>
      </ul>
      <p>
        The instinct to avoid cloning comes from languages where copies happen invisibly
        and can be expensive. In Rust, cloning is explicit &mdash; you see it in the code
        &mdash; and usually cheap. When it isn't, the profiler will tell you.
      </p>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-interior-mutability.html">#1: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#2: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><a href="rust-patterns-cow.html">#6: Cow &mdash; Borrow or Own</a></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#7: Lifetime Annotations</a></li>
          <li><strong>#8: &rsquo;static + Clone</strong></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-newtype.html">#11: Newtype</a></li>
          <li><a href="rust-patterns-typestate.html">#12: Typestate</a></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#16: Error Handling</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#19: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
