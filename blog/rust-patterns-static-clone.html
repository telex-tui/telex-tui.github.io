<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #8: 'static + Clone - Telex</title>
  <meta name="description" content="When lifetime annotations fight you in async or threaded code, cloning the data and owning it outright is often the correct solution. Profile before you optimise.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #8: <code>'static</code> + Clone &mdash; The Escape Hatch</h1>
      <div class="post-meta">May 2026</div>

      <p>
        You're spawning a thread or an async task. The API requires <code>'static</code>.
        Your data borrows from something. The compiler won't let it through. You try adding
        lifetime annotations, restructuring, wrapping things in <code>Arc</code>. The code
        gets more complex with each attempt. There's a simpler answer: clone the data.
      </p>

      <h2>The motivation</h2>

      <pre><code><span class="kw">fn</span> <span class="fn">process</span>(data: &amp;<span class="ty">str</span>) {
    std::thread::<span class="fn">spawn</span>(|| {
        <span class="mac">println!</span>(<span class="str">"{}"</span>, data);
    });
}</code></pre>

      <pre><code><span class="cm">error[E0373]: closure may outlive the current function,
              but it borrows `data`, which is owned by the current function</span></code></pre>

      <p>
        <code>thread::spawn</code> requires the closure to be <code>'static</code> &mdash;
        it can't borrow from the enclosing function because the thread might outlive it.
        The same applies to <code>tokio::spawn</code>, <code>rayon::spawn</code>, and any
        API that takes <code>F: FnOnce() + Send + 'static</code>.
      </p>

      <h2>Why everything wants <code>'static</code></h2>

      <p>
        A spawned task or thread has no guaranteed lifetime. It might run for a microsecond
        or for the rest of the program. The runtime can't prove that borrowed data will still
        be valid when the task reads it. <code>'static</code> means "this value is
        self-contained &mdash; it owns everything it needs." No dangling references possible.
      </p>
      <p>
        This applies to any owned type: <code>String</code>, <code>Vec&lt;u8&gt;</code>,
        <code>i32</code>, <code>PathBuf</code>. All owned types are <code>'static</code>
        because they don't borrow from anything. The bound isn't asking for immortal data
        &mdash; it's asking for data that doesn't depend on someone else's lifetime.
      </p>

      <h2>The pattern: clone and move</h2>

      <pre><code><span class="kw">fn</span> <span class="fn">process</span>(data: &amp;<span class="ty">str</span>) {
    <span class="kw">let</span> data = data.<span class="fn">to_string</span>(); <span class="cm">// owned copy</span>
    std::thread::<span class="fn">spawn</span>(<span class="kw">move</span> || {
        <span class="mac">println!</span>(<span class="str">"{}"</span>, data);
    });
}</code></pre>

      <p>
        <code>data.to_string()</code> creates an owned <code>String</code>. The
        <code>move</code> closure takes ownership of it. The closure is now
        <code>'static</code> because it owns everything it captures. No lifetime
        issues.
      </p>
      <p>
        For structs with multiple fields:
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">spawn_worker</span>(config: &amp;<span class="ty">Config</span>) {
    <span class="kw">let</span> config = config.<span class="fn">clone</span>();
    tokio::<span class="fn">spawn</span>(<span class="kw">async move</span> {
        <span class="cm">// config is owned â€” no lifetime constraints</span>
        <span class="fn">do_work</span>(&amp;config).<span class="kw">await</span>;
    });
}</code></pre>

      <h2>"But cloning is wasteful!"</h2>

      <p>
        This is the most common objection, and it's almost always premature. Consider what
        a clone actually costs:
      </p>
      <ul>
        <li>Cloning a <code>String</code>: one heap allocation + <code>memcpy</code> of
          the string's bytes</li>
        <li>Cloning a <code>Vec&lt;T&gt;</code>: one heap allocation + <code>memcpy</code>
          (for <code>Copy</code> types) or element-wise cloning</li>
        <li>Cloning a small struct with a few <code>String</code> fields: a handful of
          allocations</li>
      </ul>
      <p>
        Now consider the context. If you're spawning a task to make a network request
        (milliseconds), query a database (milliseconds), or do any kind of I/O, the clone
        is nanoseconds of noise. You can't measure it. The anxiety about cloning is almost
        always misplaced.
      </p>
      <p>
        <strong>Profile before you optimise.</strong> If your profiler shows that cloning is a
        bottleneck, address it. Until then, clone freely.
      </p>

      <h2><code>Arc</code> as a middle ground</h2>

      <p>
        When the data is genuinely large (megabytes, or cloned thousands of times per
        second), cloning might show up in profiles. In that case, share instead of
        copying:
      </p>

      <pre><code><span class="kw">use</span> std::sync::<span class="ty">Arc</span>;

<span class="kw">fn</span> <span class="fn">spawn_workers</span>(data: <span class="ty">Arc</span>&lt;<span class="ty">LargeDataset</span>&gt;) {
    <span class="kw">for</span> _ <span class="kw">in</span> <span class="num">0</span>..<span class="num">10</span> {
        <span class="kw">let</span> data = <span class="ty">Arc</span>::<span class="fn">clone</span>(&amp;data);
        tokio::<span class="fn">spawn</span>(<span class="kw">async move</span> {
            <span class="fn">process</span>(&amp;data).<span class="kw">await</span>;
        });
    }
}</code></pre>

      <p>
        <code>Arc::clone</code> is a reference count increment &mdash; a single atomic
        operation. All ten tasks share the same <code>LargeDataset</code> allocation.
        <code>Arc&lt;T&gt;</code> is <code>'static</code> + <code>Send</code> (when
        <code>T: Send + Sync</code>), so it satisfies spawn bounds.
      </p>

      <h2>The decision tree</h2>

      <ol>
        <li>Does the task need <code>'static</code>? If the data is already owned, you're
          done &mdash; just <code>move</code> it in.</li>
        <li>Is the data small or the clone infrequent? <strong>Clone it.</strong> This
          is the right answer 90% of the time.</li>
        <li>Is the data large and shared by many tasks? Use <code>Arc</code>.</li>
        <li>Does the data need to be mutated by multiple tasks? Use
          <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>
          (<a href="rust-patterns-arc-mutex.html">#17</a>).</li>
      </ol>

      <h2>When to use it</h2>

      <ul>
        <li>Spawning threads or async tasks that need data from the calling scope</li>
        <li>Callbacks registered across different lifetimes</li>
        <li>Any time the compiler demands <code>'static</code> and your data borrows</li>
      </ul>
      <p>
        The instinct to avoid cloning comes from languages where copies are expensive by
        default. In Rust, cloning is explicit, visible, and usually cheap. When it's not,
        the profiler will tell you.
      </p>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
