<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #7: Lifetime Annotations - Telex</title>
  <meta name="description" content="Lifetime annotations don't control how long data lives â€” they describe relationships the compiler checks. Here's the mental model that makes them click.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #7: Lifetime Annotations</h1>
      <div class="post-meta">April 2026</div>
      <p class="series-nav">Post 7 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        You write a function that returns a reference, or a struct that holds one. The
        compiler demands a lifetime annotation and you freeze. What do you write? What does
        it mean? The confusion usually comes from thinking lifetimes are instructions to the
        compiler. They're not. They're descriptions of relationships that already exist.
      </p>

      <h2>The motivation</h2>

      <p>
        A function takes two string slices and returns whichever is longer:
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">longest</span>(a: &amp;<span class="kw">str</span>, b: &amp;<span class="kw">str</span>) -&gt; &amp;<span class="kw">str</span> {
    <span class="kw">if</span> a.<span class="fn">len</span>() &gt; b.<span class="fn">len</span>() { a } <span class="kw">else</span> { b }
}</code></pre>

      <p>
        The compiler:
      </p>

      <pre><code><span class="cm">error[E0106]: missing lifetime specifier
  -- this function's return type contains a borrowed value,
     but the signature does not say whether it is borrowed
     from `a` or `b`</span></code></pre>

      <p>
        The return type is a reference. It must refer to something that outlives it. But the
        compiler can't tell whether the returned reference comes from <code>a</code> or
        <code>b</code> (it depends on runtime values), so it can't check safety without
        your help.
      </p>

      <h2>Elision rules: what the compiler infers</h2>

      <p>
        Most of the time, you don't need lifetime annotations. Rust has three elision rules
        that let the compiler fill them in:
      </p>
      <ol>
        <li>Each reference parameter gets its own lifetime:
          <code>fn foo(a: &amp;str, b: &amp;str)</code> becomes
          <code>fn foo&lt;'a, 'b&gt;(a: &amp;'a str, b: &amp;'b str)</code></li>
        <li>If there's exactly one input lifetime, it's applied to all output references:
          <code>fn foo(a: &amp;str) -&gt; &amp;str</code> becomes
          <code>fn foo&lt;'a&gt;(a: &amp;'a str) -&gt; &amp;'a str</code></li>
        <li>If one of the parameters is <code>&amp;self</code> or
          <code>&amp;mut self</code>, its lifetime is applied to all output references</li>
      </ol>
      <p>
        The <code>longest</code> function fails because it has <em>two</em> input lifetimes
        and neither is <code>&amp;self</code>. The compiler can't pick one. You have to.
      </p>

      <h2>The mental model: constraints, not instructions</h2>

      <p>
        A lifetime annotation says: "these references are related." It does not make data
        live longer or shorter. You're describing a fact about your code so the compiler can
        check it.
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">longest</span>&lt;<span class="kw">'a</span>&gt;(a: &amp;<span class="kw">'a</span> <span class="kw">str</span>, b: &amp;<span class="kw">'a</span> <span class="kw">str</span>) -&gt; &amp;<span class="kw">'a</span> <span class="kw">str</span> {
    <span class="kw">if</span> a.<span class="fn">len</span>() &gt; b.<span class="fn">len</span>() { a } <span class="kw">else</span> { b }
}</code></pre>

      <p>
        Read this as: "the returned reference is valid for at least as long as the shorter
        of <code>a</code> and <code>b</code>." Both inputs share the lifetime
        <code>'a</code>, so the compiler interprets <code>'a</code> as the intersection
        &mdash; the region where both are valid. The return value is constrained to that
        region.
      </p>
      <p>
        Now the compiler can check every call site. If <code>a</code> lives for 10 lines and
        <code>b</code> lives for 5 lines, the returned reference is valid for at most 5
        lines. If someone tries to use it on line 7, the compiler rejects it.
      </p>

      <h2>Multiple lifetimes</h2>

      <p>
        Sometimes the inputs have independent lifetimes and you want to express which one
        the return borrows from:
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">first</span>&lt;<span class="kw">'a</span>, <span class="kw">'b</span>&gt;(a: &amp;<span class="kw">'a</span> <span class="kw">str</span>, b: &amp;<span class="kw">'b</span> <span class="kw">str</span>) -&gt; &amp;<span class="kw">'a</span> <span class="kw">str</span> {
    a
}</code></pre>

      <p>
        This says: "the return borrows from <code>a</code> only. <code>b</code>'s lifetime
        is irrelevant." The compiler knows <code>b</code> can be dropped without affecting
        the returned reference.
      </p>

      <h2>Structs that hold references</h2>

      <p>
        When a struct stores a reference, it needs a lifetime parameter to express the
        constraint: the struct can't outlive the data it borrows.
      </p>

      <pre><code><span class="kw">struct</span> <span class="ty">Excerpt</span>&lt;<span class="kw">'a</span>&gt; {
    text: &amp;<span class="kw">'a</span> <span class="kw">str</span>,
}

<span class="kw">fn</span> <span class="fn">main</span>() {
    <span class="kw">let</span> excerpt;
    {
        <span class="kw">let</span> novel = <span class="ty">String</span>::<span class="fn">from</span>(<span class="str">"Call me Ishmael..."</span>);
        excerpt = <span class="ty">Excerpt</span> { text: &amp;novel };
    } <span class="cm">// novel dropped here</span>
    <span class="cm">// println!("{}", excerpt.text); // ERROR: `novel` does not live long enough</span>
}</code></pre>

      <p>
        The lifetime <code>'a</code> in <code>Excerpt&lt;'a&gt;</code> means: "this struct
        borrows from something, and it can't outlive that something." The compiler catches
        the dangling reference at compile time.
      </p>

      <h2>When lifetimes get painful</h2>

      <p>
        If you find yourself adding lifetime parameters to struct after struct, passing them
        through generic bounds, and fighting increasingly complex error messages, step back.
        The complexity is usually a signal.
      </p>
      <p>
        The escape hatch is ownership: use <code>String</code> instead of <code>&amp;str</code>.
        Use <code>Vec&lt;T&gt;</code> instead of <code>&amp;[T]</code>. Owned types have no
        lifetime constraints. The struct that holds a <code>String</code> can live anywhere,
        be sent to threads, be stored in collections, without any of the restrictions that
        references bring.
      </p>
      <p>
        This isn't a cop-out. Owning data is often the right design. References are an
        optimisation &mdash; they avoid copies by borrowing in place. If the optimisation
        is costing you more in complexity than it saves in allocation, own the data.
        The next post covers this trade-off directly:
        <a href="rust-patterns-static-clone.html"><code>'static</code> + Clone</a>.
      </p>

      <h2>When to use lifetime annotations</h2>

      <ul>
        <li>Functions that return a reference derived from an input reference, where elision
          doesn't apply</li>
        <li>Structs that borrow data (parsers holding a <code>&amp;str</code>,
          iterators holding a <code>&amp;[T]</code>)</li>
        <li>Trait bounds where borrowed data flows through</li>
      </ul>
      <p>
        When annotations get deeply nested or thread through many layers of generics,
        it's usually a sign to switch from borrowing to owning.
      </p>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-interior-mutability.html">#1: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#2: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><a href="rust-patterns-cow.html">#6: Cow &mdash; Borrow or Own</a></li>
          <li><strong>#7: Lifetime Annotations</strong></li>
          <li><a href="rust-patterns-static-clone.html">#8: &rsquo;static + Clone</a></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-newtype.html">#11: Newtype</a></li>
          <li><a href="rust-patterns-typestate.html">#12: Typestate</a></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#16: Error Handling</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#19: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
