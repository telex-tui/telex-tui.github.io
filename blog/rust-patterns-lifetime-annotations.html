<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #7: Lifetime Annotations - Telex</title>
  <meta name="description" content="Lifetime annotations don't control how long data lives — they describe relationships the compiler checks. Here's the mental model that makes them click.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #7: Lifetime Annotations</h1>
      <div class="post-meta">April 2026</div>
      <p class="series-nav">Post 7 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        You write a function that returns a reference, or a struct that holds one. The
        compiler asks for a lifetime annotation and you freeze. What are you supposed to
        write? What does it even mean? Most of the confusion comes from thinking you're
        giving the compiler instructions. You're not. You're describing relationships that
        already exist in your code.
      </p>

      <h2>The motivation</h2>

      <p>
        A function takes two string slices and returns whichever is longer:
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">longest</span>(a: &amp;<span class="kw">str</span>, b: &amp;<span class="kw">str</span>) -&gt; &amp;<span class="kw">str</span> {
    <span class="kw">if</span> a.<span class="fn">len</span>() &gt; b.<span class="fn">len</span>() { a } <span class="kw">else</span> { b }
}</code></pre>

      <p>
        The compiler:
      </p>

      <pre><code><span class="cm">error[E0106]: missing lifetime specifier
  -- this function's return type contains a borrowed value,
     but the signature does not say whether it is borrowed
     from `a` or `b`</span></code></pre>

      <p>
        The return type is a reference, so it must point to something that's still alive
        when the caller uses it. But the compiler can't tell whether the returned reference
        comes from <code>a</code> or <code>b</code> &mdash; that depends on which string
        is longer at runtime &mdash; so it can't check safety without your help.
      </p>

      <h2>Elision rules: what the compiler infers</h2>

      <p>
        Most of the time, you don't write lifetime annotations at all. Rust has three
        elision rules that let the compiler fill them in automatically:
      </p>
      <ol>
        <li>Each reference parameter gets its own lifetime.
          <code>fn foo(a: &amp;str, b: &amp;str)</code> becomes
          <code>fn foo&lt;'a, 'b&gt;(a: &amp;'a str, b: &amp;'b str)</code>.</li>
        <li>If there's exactly one input lifetime, the compiler uses it for all output
          references too.
          <code>fn foo(a: &amp;str) -&gt; &amp;str</code> becomes
          <code>fn foo&lt;'a&gt;(a: &amp;'a str) -&gt; &amp;'a str</code>.</li>
        <li>If one of the parameters is <code>&amp;self</code> or
          <code>&amp;mut self</code>, the compiler uses that lifetime for all output
          references.</li>
      </ol>
      <p>
        The <code>longest</code> function hits none of these rules &mdash; it has
        <em>two</em> input lifetimes and neither is <code>&amp;self</code>. The compiler
        doesn't know which one the return value borrows from, so you have to say.
      </p>

      <h2>The mental model: constraints, not instructions</h2>

      <p>
        A lifetime annotation says: "these references are connected." It doesn't make data
        live longer or shorter. You're telling the compiler a fact about your code so it
        can verify that fact everywhere the function is called.
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">longest</span>&lt;<span class="kw">'a</span>&gt;(a: &amp;<span class="kw">'a</span> <span class="kw">str</span>, b: &amp;<span class="kw">'a</span> <span class="kw">str</span>) -&gt; &amp;<span class="kw">'a</span> <span class="kw">str</span> {
    <span class="kw">if</span> a.<span class="fn">len</span>() &gt; b.<span class="fn">len</span>() { a } <span class="kw">else</span> { b }
}</code></pre>

      <p>
        Read this as: "the returned reference lives at most as long as whichever input
        dies first." Both inputs share the lifetime <code>'a</code>, so the compiler uses
        the overlap &mdash; the window when both are still alive. The return value can't
        outlive either one.
      </p>
      <p>
        Now the compiler can check every call site. Say <code>a</code> is alive for 10 lines
        and <code>b</code> is alive for 5. The returned reference is good for at most 5
        lines. If you try to use it on line 7, the compiler rejects it.
      </p>

      <h2>Multiple lifetimes</h2>

      <p>
        Sometimes the inputs live for different amounts of time and you want to say exactly
        which one the return value borrows from:
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">first</span>&lt;<span class="kw">'a</span>, <span class="kw">'b</span>&gt;(a: &amp;<span class="kw">'a</span> <span class="kw">str</span>, b: &amp;<span class="kw">'b</span> <span class="kw">str</span>) -&gt; &amp;<span class="kw">'a</span> <span class="kw">str</span> {
    a
}</code></pre>

      <p>
        This says: "the return value borrows from <code>a</code> only &mdash;
        <code>b</code> doesn't matter." So the borrow checker permits dropping
        <code>b</code> even while the returned reference is still in use.
      </p>

      <h2>Structs that hold references</h2>

      <p>
        When a struct holds a reference in one of its fields, it needs a lifetime parameter.
        That parameter tells the compiler: this struct can't outlive the data it's
        borrowing.
      </p>

      <pre><code><span class="kw">struct</span> <span class="ty">Excerpt</span>&lt;<span class="kw">'a</span>&gt; {
    text: &amp;<span class="kw">'a</span> <span class="kw">str</span>,
}

<span class="kw">fn</span> <span class="fn">main</span>() {
    <span class="kw">let</span> excerpt;
    {
        <span class="kw">let</span> novel = <span class="ty">String</span>::<span class="fn">from</span>(<span class="str">"Call me Ishmael..."</span>);
        excerpt = <span class="ty">Excerpt</span> { text: &amp;novel };
    } <span class="cm">// novel dropped here</span>
    <span class="cm">// println!("{}", excerpt.text); // ERROR: `novel` does not live long enough</span>
}</code></pre>

      <p>
        The <code>'a</code> in <code>Excerpt&lt;'a&gt;</code> means: "this struct borrows
        data, and the data has to stay alive at least as long as the struct does." Here,
        <code>novel</code> gets dropped at the end of the block, but <code>excerpt</code>
        tries to live past it &mdash; so the compiler stops you.
      </p>

      <h2>When lifetimes get painful</h2>

      <p>
        If you keep adding lifetime parameters to struct after struct, threading them through
        generic bounds, and fighting longer and longer error messages &mdash; stop.
        That complexity is telling you something.
      </p>
      <p>
        The escape hatch is to own the data. Use <code>String</code> instead of
        <code>&amp;str</code>. Use <code>Vec&lt;T&gt;</code> instead of
        <code>&amp;[T]</code>. Owned types have no lifetime constraints. A struct that
        holds a <code>String</code> can live anywhere, move to another thread, sit in a
        collection &mdash; none of the restrictions that references bring.
      </p>
      <p>
        This isn't a cop-out. Owning data is often the right call. References are an
        optimisation &mdash; they avoid copies by pointing to the original. If that
        optimisation costs you more in code complexity than it saves in allocations,
        just own the data. The next post goes deeper on this trade-off:
        <a href="rust-patterns-static-clone.html"><code>'static</code> + Clone</a>.
      </p>

      <h2>What does this cost?</h2>

      <p>
        Lifetime annotations are erased during compilation — they exist only in the
        type checker, not in the generated code. A function with
        <code>&lt;'a&gt;</code> parameters compiles to exactly the same machine code
        as one without them. There is no tag, no counter, no runtime check. Lifetimes
        are part of Rust's type system the way const-correctness is in C++ — they
        constrain what the compiler accepts, but vanish before code generation. Without
        lifetime annotations, the compiler would have to either reject all functions
        that return references (too restrictive) or accept them without proof of
        validity (unsound). Lifetimes let you express the proof the compiler needs,
        at zero runtime cost.
      </p>

      <h2>When to use lifetime annotations</h2>

      <ul>
        <li>Functions that return a reference taken from one of their inputs, when the
          elision rules can't figure out which input it comes from</li>
        <li>Structs that borrow data instead of owning it &mdash; like a parser holding a
          <code>&amp;str</code>, or an iterator holding a <code>&amp;[T]</code></li>
        <li>Trait bounds where borrowed data passes through generic code</li>
      </ul>
      <p>
        If your annotations start nesting deep or spreading through many layers of generics,
        that's usually a sign you should own the data instead of borrowing it.
      </p>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-interior-mutability.html">#1: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#2: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><a href="rust-patterns-cow.html">#6: Cow &mdash; Borrow or Own</a></li>
          <li><strong>#7: Lifetime Annotations</strong></li>
          <li><a href="rust-patterns-static-clone.html">#8: &rsquo;static + Clone</a></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-newtype.html">#11: Newtype</a></li>
          <li><a href="rust-patterns-typestate.html">#12: Typestate</a></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#16: Error Handling</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#19: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
