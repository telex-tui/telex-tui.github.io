<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>40 Rust Patterns That Matter - Telex</title>
  <meta name="description" content="A field guide to forty patterns that show up constantly in real Rust code. Each one is a small decision -- a moment where you know what you want but don't know the idiomatic way to say it.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>40 Rust Patterns That Matter</h1>
      <div class="post-meta">February 2026</div>

      <p>
        You can read the Rust standard library docs cover-to-cover and still not
        know how to <em>think</em> in Rust. The docs tell you what each method does.
        They don't tell you when you'd reach for it, or which three methods combine
        to solve the problem you're actually staring at.
      </p>

      <p>
        This is a field guide to forty patterns that show up constantly in real
        Rust code. Each one is a small decision -- a moment where you know what you
        want but don't know the idiomatic way to say it. They're grouped by the
        kind of problem they solve, not by which trait they live on.
      </p>

      <h2>I. Errors and Options</h2>

      <p>
        These patterns are about control flow. Rust doesn't have exceptions, so
        <code>Result</code> and <code>Option</code> <em>are</em> your control flow.
        The patterns here are the grammar for saying "this might fail" and "here's
        what to do about it."
      </p>

      <h3>1. The Success or Bail</h3>

      <p>
        You have a list of tasks. If they all succeed, you want the collected
        results. If any one fails, the whole batch is a failure.
      </p>

      <p>
        The trick is that <code>collect()</code> knows how to do this. When you
        collect an iterator of <code>Result&lt;T, E&gt;</code> into a
        <code>Result&lt;Vec&lt;T&gt;, E&gt;</code>, Rust short-circuits on the first
        error and gives you back that error. If everything succeeds, you get
        <code>Ok(vec_of_results)</code>.
      </p>

      <pre><code><span class="kw">let</span> results: <span class="ty">Result</span>&lt;<span class="ty">Vec</span>&lt;_&gt;, _&gt; = items.<span class="fn">iter</span>().<span class="fn">map</span>(|x| x.<span class="fn">try_into</span>()).<span class="fn">collect</span>();</code></pre>

      <p>
        This replaces the loop-with-early-return pattern you'd write in C. The
        <code>FromIterator</code> implementation for <code>Result</code> handles
        the bail-out logic internally.
      </p>

      <h3>2. The Error Pivot</h3>

      <p>
        You're inside a function that returns <code>Result</code>, but you have an
        <code>Option</code>. You need to turn "nothing here" into a specific error
        so you can use <code>?</code> to propagate it.
      </p>

      <pre><code><span class="kw">let</span> val = maybe_user.<span class="fn">ok_or</span>(<span class="ty">Error</span>::NotFound)?;</code></pre>

      <p>
        <code>ok_or</code> bridges the two types: <code>Some(x)</code> becomes
        <code>Ok(x)</code>, and <code>None</code> becomes
        <code>Err(whatever_you_passed)</code>. If constructing the error is
        expensive, use <code>ok_or_else</code> with a closure so it only runs on
        the <code>None</code> path.
      </p>

      <pre><code><span class="cm">// This builds the error string even when maybe_user is Some:</span>
<span class="kw">let</span> val = maybe_user.<span class="fn">ok_or</span>(<span class="fn">format!</span>(<span class="str">"User {} not found"</span>, id))?;

<span class="cm">// This only builds it when needed:</span>
<span class="kw">let</span> val = maybe_user.<span class="fn">ok_or_else</span>(|| <span class="fn">format!</span>(<span class="str">"User {} not found"</span>, id))?;</code></pre>

      <h3>3. The Silent Discard</h3>

      <p>
        You have a list of inputs and some of them are garbage. You want to keep
        the good ones and pretend the bad ones never existed. No error handling,
        no logging -- just drop them on the floor.
      </p>

      <p>
        Map the fallible operation to an <code>Option</code> with <code>.ok()</code>,
        then use <code>filter_map</code> to keep only the <code>Some</code> values.
      </p>

      <pre><code><span class="kw">let</span> valid: <span class="ty">Vec</span>&lt;<span class="ty">i32</span>&gt; = inputs.<span class="fn">iter</span>().<span class="fn">filter_map</span>(|s| s.<span class="fn">parse</span>().<span class="fn">ok</span>()).<span class="fn">collect</span>();
<span class="cm">// ["1", "abc", "3"] -> [1, 3]</span></code></pre>

      <p>
        The <code>.ok()</code> call converts <code>Result&lt;T, E&gt;</code> into
        <code>Option&lt;T&gt;</code>, discarding the error. Then <code>filter_map</code>
        does a filter-and-unwrap in one step: keep the <code>Some</code>s, skip
        the <code>None</code>s.
      </p>

      <h3>4. The Specific Failure Context</h3>

      <p>
        An operation failed, but the error is too generic. "File not found" isn't
        helpful when you know <em>which</em> file and <em>why</em> you were reading
        it. You want to wrap the error in something more specific without losing the
        original.
      </p>

      <pre><code><span class="kw">let</span> config = <span class="fn">load_file</span>(path)
    .<span class="fn">map_err</span>(|e| <span class="ty">AppError</span>::ConfigLoad { path: path.<span class="fn">into</span>(), source: e })?;</code></pre>

      <p>
        <code>map_err</code> transforms only the error side and leaves <code>Ok</code>
        values completely untouched. It's the error equivalent of <code>map</code>,
        which transforms only the success side.
      </p>

      <h3>5. The Fallback Chain</h3>

      <p>
        You have multiple places a value might come from. Try the first; if it's
        <code>None</code>, try the second; if that's <code>None</code>, try the third.
      </p>

      <pre><code><span class="kw">let</span> color = user_preference
    .<span class="fn">or</span>(theme_default)
    .<span class="fn">or</span>(<span class="ty">Some</span>(<span class="ty">Color</span>::Black));</code></pre>

      <p>
        <code>or</code> on <code>Option</code> returns the first <code>Some</code>
        it finds. The same pattern works on <code>Result</code> -- the first
        <code>Ok</code> wins. If computing the fallback is expensive, use
        <code>or_else</code> with a closure:
      </p>

      <pre><code><span class="kw">let</span> config = <span class="fn">load_from_file</span>()
    .<span class="fn">or_else</span>(|_| <span class="fn">load_from_env</span>())
    .<span class="fn">or_else</span>(|_| <span class="fn">load_defaults</span>());</code></pre>

      <p>
        This is a try-one-then-try-another chain, and it reads exactly like one.
      </p>

      <h3>6. The Safe Default</h3>

      <p>
        A value might be missing, and you're fine with the type's default
        (<code>0</code> for numbers, <code>""</code> for strings, <code>[]</code>
        for vecs). You don't want to spell out what the default is because the type
        already knows.
      </p>

      <pre><code><span class="kw">let</span> count = maybe_count.<span class="fn">unwrap_or_default</span>(); <span class="cm">// None -> 0 for integers</span>
<span class="kw">let</span> name = maybe_name.<span class="fn">unwrap_or_default</span>();   <span class="cm">// None -> "" for String</span></code></pre>

      <p>
        This requires that <code>T</code> implements <code>Default</code>. It's a
        small thing, but it eliminates a class of "what should the default be?"
        decisions and makes the intent crystal clear: "I want the zero value."
      </p>

      <h3>7. The Nested Collapse</h3>

      <p>
        You end up with an <code>Option&lt;Option&lt;T&gt;&gt;</code> -- usually
        because you mapped over an <code>Option</code> with a function that itself
        returns an <code>Option</code>. You want to flatten it down to a single
        <code>Option&lt;T&gt;</code>.
      </p>

      <pre><code><span class="kw">let</span> nested: <span class="ty">Option</span>&lt;<span class="ty">Option</span>&lt;<span class="ty">i32</span>&gt;&gt; = <span class="ty">Some</span>(<span class="ty">Some</span>(<span class="num">42</span>));
<span class="kw">let</span> flat: <span class="ty">Option</span>&lt;<span class="ty">i32</span>&gt; = nested.<span class="fn">flatten</span>(); <span class="cm">// Some(42)</span>

<span class="kw">let</span> also_nested: <span class="ty">Option</span>&lt;<span class="ty">Option</span>&lt;<span class="ty">i32</span>&gt;&gt; = <span class="ty">Some</span>(<span class="ty">None</span>);
<span class="kw">let</span> also_flat: <span class="ty">Option</span>&lt;<span class="ty">i32</span>&gt; = also_nested.<span class="fn">flatten</span>(); <span class="cm">// None</span></code></pre>

      <p>
        This comes up more than you'd expect. Any time you call
        <code>.map(|x| something_that_returns_option(x))</code> you get the double
        wrapping. You can either switch to <code>and_then</code> (pattern 21 below)
        to avoid it in the first place, or <code>flatten</code> to clean it up after.
      </p>

      <h3>8. The Conditional Keep</h3>

      <p>
        You have an <code>Option</code> and you want to keep it only if the inner
        value passes a test. If it fails the test, turn the whole thing into
        <code>None</code>.
      </p>

      <pre><code><span class="kw">let</span> port: <span class="ty">Option</span>&lt;<span class="ty">u16</span>&gt; = <span class="ty">Some</span>(<span class="num">8080</span>);
<span class="kw">let</span> valid_port = port.<span class="fn">filter</span>(|&amp;p| p &gt; <span class="num">1024</span>);  <span class="cm">// Some(8080)</span>
<span class="kw">let</span> low_port = <span class="ty">Some</span>(<span class="num">80</span>_u16).<span class="fn">filter</span>(|&amp;p| p &gt; <span class="num">1024</span>); <span class="cm">// None</span></code></pre>

      <p>
        <code>filter</code> on <code>Option</code> is the gatekeeper. It either
        lets the <code>Some</code> through or downgrades it to <code>None</code>.
        Useful for validation chains where you want to keep everything in
        <code>Option</code>-land without unwrapping.
      </p>

      <h3>9. The Borrow, Don't Move</h3>

      <p>
        You have an <code>Option&lt;String&gt;</code> and you want to peek at the
        contents without taking ownership. You want <code>Option&lt;&amp;String&gt;</code>
        or <code>Option&lt;&amp;str&gt;</code>.
      </p>

      <pre><code><span class="kw">let</span> name: <span class="ty">Option</span>&lt;<span class="ty">String</span>&gt; = <span class="ty">Some</span>(<span class="str">"Alice"</span>.<span class="fn">to_string</span>());

<span class="cm">// as_ref: Option&lt;String&gt; -> Option&lt;&amp;String&gt;</span>
<span class="kw">if</span> name.<span class="fn">as_ref</span>().<span class="fn">is_some_and</span>(|s| s.<span class="fn">starts_with</span>(<span class="str">'A'</span>)) {
    <span class="cm">// name is still usable here</span>
}

<span class="cm">// as_deref: Option&lt;String&gt; -> Option&lt;&amp;str&gt; (even better)</span>
<span class="kw">match</span> name.<span class="fn">as_deref</span>() {
    <span class="ty">Some</span>(<span class="str">"Alice"</span>) =&gt; <span class="fn">println!</span>(<span class="str">"Found Alice"</span>),
    <span class="ty">Some</span>(other) =&gt; <span class="fn">println!</span>(<span class="str">"Found {other}"</span>),
    <span class="ty">None</span> =&gt; <span class="fn">println!</span>(<span class="str">"Nobody home"</span>),
}</code></pre>

      <p>
        <code>as_ref</code> gives you a reference to whatever's inside.
        <code>as_deref</code> goes one step further and dereferences it too, so
        <code>Option&lt;String&gt;</code> becomes <code>Option&lt;&amp;str&gt;</code>.
        The same pair works on <code>Result</code>: <code>as_ref</code> gives you
        <code>Result&lt;&amp;T, &amp;E&gt;</code>.
      </p>

      <h3>10. The Map the Wrapper</h3>

      <p>
        You have a <code>Result</code> or <code>Option</code> and want to transform
        what's inside without unwrapping it. This is the bread-and-butter combinator.
      </p>

      <pre><code><span class="kw">let</span> maybe_len: <span class="ty">Option</span>&lt;<span class="ty">usize</span>&gt; = maybe_name.<span class="fn">map</span>(|s| s.<span class="fn">len</span>());
<span class="kw">let</span> parsed: <span class="ty">Result</span>&lt;<span class="ty">i32</span>, _&gt; = line.<span class="fn">map</span>(|s| s.<span class="fn">trim</span>().<span class="fn">len</span>() <span class="kw">as</span> <span class="ty">i32</span>);</code></pre>

      <p>
        <code>map</code> on <code>Option</code> transforms <code>Some(x)</code> to
        <code>Some(f(x))</code> and leaves <code>None</code> alone.
        <code>map</code> on <code>Result</code> transforms <code>Ok(x)</code> to
        <code>Ok(f(x))</code> and leaves <code>Err</code> alone. It's how you work
        with wrapped values without leaving the wrapper.
      </p>

      <h2>II. Ownership and Memory</h2>

      <p>
        These patterns are about efficiency -- knowing when you're copying data,
        when you're borrowing it, and when you're consuming it. In C, you'd manage
        this with conventions and discipline. In Rust, the patterns have names.
      </p>

      <h3>11. The Cheap Reference Upgrade</h3>

      <p>
        You have an iterator yielding references to small, <code>Copy</code> types
        like <code>&amp;i32</code> or <code>&amp;bool</code>, but the next function
        in the chain expects owned values.
      </p>

      <pre><code><span class="kw">let</span> sum: <span class="ty">i32</span> = numbers.<span class="fn">iter</span>().<span class="fn">copied</span>().<span class="fn">sum</span>();
<span class="kw">let</span> flags: <span class="ty">Vec</span>&lt;<span class="ty">bool</span>&gt; = bits.<span class="fn">iter</span>().<span class="fn">copied</span>().<span class="fn">collect</span>();</code></pre>

      <p>
        <code>copied()</code> turns <code>&amp;T</code> into <code>T</code> for any
        type that implements <code>Copy</code>. It's a memcpy of a few bytes --
        trivially cheap. When you see <code>copied()</code> in code, you know
        nothing expensive is happening.
      </p>

      <h3>12. The Expensive Reference Upgrade</h3>

      <p>
        Same situation, but the types involve heap allocations. You have
        <code>&amp;String</code> or <code>&amp;Vec&lt;T&gt;</code> and you need
        owned versions. You accept the cost.
      </p>

      <pre><code><span class="kw">let</span> owned_names: <span class="ty">Vec</span>&lt;<span class="ty">String</span>&gt; = name_refs.<span class="fn">iter</span>().<span class="fn">cloned</span>().<span class="fn">collect</span>();</code></pre>

      <p>
        <code>cloned()</code> calls <code>.clone()</code> on each element. It
        compiles for anything that implements <code>Clone</code>, but unlike
        <code>copied()</code>, it might allocate. When you see <code>cloned()</code>
        in a review, it's a signal: "heap allocations happening here, and the
        author knows it."
      </p>

      <h3>13. The Resource Recycle</h3>

      <p>
        You're done with a container -- a <code>HashMap</code>, a <code>Vec</code>,
        a <code>BTreeSet</code> -- but you need the individual items as owned
        values. You want to tear the container apart.
      </p>

      <pre><code><span class="kw">for</span> (key, value) <span class="kw">in</span> map.<span class="fn">into_iter</span>() {
    <span class="cm">// key and value are owned -- map is consumed</span>
    other_map.<span class="fn">insert</span>(key, value);
}</code></pre>

      <p>
        <code>into_iter()</code> consumes the collection and yields owned items.
        Compare: <code>.iter()</code> borrows and yields references,
        <code>.iter_mut()</code> borrows mutably. The <code>into_</code> prefix
        follows the standard convention -- it eats the original.
      </p>

      <h3>14. The Peeking into the Box</h3>

      <p>
        You have a <code>String</code> inside an <code>Option</code> and you want
        to call string methods on it -- check the length, see if it starts with
        something -- without moving it out.
      </p>

      <pre><code><span class="cm">// as_deref: Option&lt;String&gt; -> Option&lt;&amp;str&gt;</span>
<span class="kw">let</span> is_empty = maybe_name.<span class="fn">as_deref</span>().<span class="fn">map_or</span>(<span class="kw">true</span>, |s| s.<span class="fn">is_empty</span>());

<span class="kw">let</span> starts_with_a = maybe_name.<span class="fn">as_deref</span>()
    .<span class="fn">is_some_and</span>(|s| s.<span class="fn">starts_with</span>(<span class="str">'A'</span>));</code></pre>

      <p>
        <code>as_deref()</code> uses <code>Deref</code> coercion to give you a
        borrowed view: <code>Option&lt;String&gt;</code> becomes
        <code>Option&lt;&amp;str&gt;</code>,
        <code>Option&lt;Vec&lt;T&gt;&gt;</code> becomes
        <code>Option&lt;&amp;[T]&gt;</code>,
        <code>Option&lt;Box&lt;T&gt;&gt;</code> becomes
        <code>Option&lt;&amp;T&gt;</code>. You get to peek without taking anything out.
      </p>

      <h3>15. The Temporary Theft</h3>

      <p>
        You have an <code>Option</code> inside a mutable struct and you need to take
        the value out, leaving <code>None</code> behind. You're not borrowing --
        you're <em>stealing</em>, but you're leaving the struct in a valid state.
      </p>

      <pre><code><span class="kw">struct</span> <span class="ty">Connection</span> {
    pending_message: <span class="ty">Option</span>&lt;<span class="ty">Message</span>&gt;,
}

<span class="kw">impl</span> <span class="ty">Connection</span> {
    <span class="kw">fn</span> <span class="fn">flush</span>(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; <span class="ty">Option</span>&lt;<span class="ty">Message</span>&gt; {
        <span class="kw">self</span>.pending_message.<span class="fn">take</span>() <span class="cm">// Returns the Message, leaves None</span>
    }
}</code></pre>

      <p>
        <code>Option::take()</code> swaps the contents with <code>None</code> and
        gives you what was there. It's the clean way to move a value out of a
        mutable reference without <code>unsafe</code>. You'll see this constantly in
        state machines, buffered I/O, and event systems.
      </p>

      <h3>16. The Hot Swap</h3>

      <p>
        You need to replace a value but also need the old one back. You can't just
        assign because you need both the old and new values.
      </p>

      <pre><code><span class="kw">use</span> std::mem;

<span class="kw">let</span> <span class="kw">mut</span> current = <span class="ty">State</span>::Running;
<span class="kw">let</span> previous = mem::<span class="fn">replace</span>(&amp;<span class="kw">mut</span> current, <span class="ty">State</span>::Paused);
<span class="cm">// current is now Paused, previous is Running</span></code></pre>

      <p>
        <code>mem::replace</code> puts a new value in and hands you the old one.
        It's how you do atomic-feeling swaps without <code>Clone</code> and without
        leaving the variable in an undefined state. Useful any time you need to
        transition state and react to what the state was.
      </p>

      <h3>17. The Drain and Keep</h3>

      <p>
        You need to remove some elements from a <code>Vec</code>, but you want both
        the removed elements <em>and</em> the remaining vec -- and you don't want
        to clone anything.
      </p>

      <pre><code><span class="kw">let</span> <span class="kw">mut</span> items = <span class="fn">vec!</span>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>];

<span class="cm">// drain a range: removes and yields elements 1..3</span>
<span class="kw">let</span> removed: <span class="ty">Vec</span>&lt;<span class="ty">i32</span>&gt; = items.<span class="fn">drain</span>(<span class="num">1</span>..<span class="num">3</span>).<span class="fn">collect</span>();
<span class="cm">// removed = [2, 3], items = [1, 4, 5]</span>

<span class="cm">// drain all: empties the vec but keeps the allocation</span>
<span class="kw">let</span> all: <span class="ty">Vec</span>&lt;<span class="ty">i32</span>&gt; = items.<span class="fn">drain</span>(..).<span class="fn">collect</span>();
<span class="cm">// all = [1, 4, 5], items = [] (but buffer is still allocated)</span></code></pre>

      <p>
        <code>drain</code> is the surgical removal tool. It removes a range
        in-place, yields the removed elements as an iterator, and shifts remaining
        elements to fill the gap. The vec's heap allocation is preserved, which
        matters when you're draining and refilling in a loop.
      </p>

      <h3>18. The Cow Dance</h3>

      <p>
        You have a function that sometimes needs to modify a string and sometimes
        doesn't. You don't want to clone every time "just in case."
      </p>

      <pre><code><span class="kw">use</span> std::borrow::<span class="ty">Cow</span>;

<span class="kw">fn</span> <span class="fn">normalize</span>(input: &amp;<span class="ty">str</span>) -&gt; <span class="ty">Cow</span>&lt;<span class="ty">str</span>&gt; {
    <span class="kw">if</span> input.<span class="fn">contains</span>(<span class="str">'\t'</span>) {
        <span class="ty">Cow</span>::<span class="fn">Owned</span>(input.<span class="fn">replace</span>(<span class="str">'\t'</span>, <span class="str">"    "</span>))
    } <span class="kw">else</span> {
        <span class="ty">Cow</span>::<span class="fn">Borrowed</span>(input) <span class="cm">// No allocation needed</span>
    }
}</code></pre>

      <p>
        <code>Cow</code> -- "clone on write" -- is either a reference or an owned
        value. It lets you defer the allocation decision. When most inputs don't
        need modification, this avoids the heap allocation entirely. You'll see it
        in parsers, config processors, and anywhere strings are conditionally
        transformed.
      </p>

      <h2>III. Iterators</h2>

      <p>
        Iterators are Rust's data processing pipeline. These patterns are the
        individual pipe fittings -- each one solves a specific "I have this, I want
        that" transformation.
      </p>

      <h3>19. The Search and Transform</h3>

      <p>
        You want to find the first item in a collection that matches some condition,
        and then immediately extract or transform a value from it.
      </p>

      <pre><code><span class="kw">let</span> first_admin_email = users.<span class="fn">iter</span>()
    .<span class="fn">find_map</span>(|u| <span class="kw">if</span> u.is_admin { <span class="ty">Some</span>(&amp;u.email) } <span class="kw">else</span> { <span class="ty">None</span> });</code></pre>

      <p>
        <code>find_map</code> combines <code>find</code> and <code>map</code> into
        one pass. Your closure returns <code>Some(value)</code> to say "found it,
        and here's what I want from it" or <code>None</code> to say "keep looking."
        It short-circuits on the first <code>Some</code>.
      </p>

      <h3>20. The Dynamic Boundary</h3>

      <p>
        You're processing a stream of data and you need to stop the moment a
        condition is no longer true. Not "skip the ones that fail" --
        <em>stop entirely</em>.
      </p>

      <pre><code><span class="cm">// Read header lines until the first blank line</span>
<span class="kw">let</span> headers: <span class="ty">Vec</span>&lt;_&gt; = lines.<span class="fn">iter</span>()
    .<span class="fn">take_while</span>(|l| !l.<span class="fn">is_empty</span>())
    .<span class="fn">collect</span>();</code></pre>

      <p>
        <code>take_while</code> is a fence, not a filter. Once the predicate returns
        <code>false</code>, the iterator is done -- even if later elements would
        pass. This is what you want for things with structure: headers before a blank
        line, sorted runs, leading whitespace.
      </p>

      <h3>21. The Custom Rank</h3>

      <p>
        You want the "best" item in a list, where "best" is defined by a property
        you can extract -- the largest file, the most recent date, the shortest name.
      </p>

      <pre><code><span class="kw">let</span> largest = files.<span class="fn">iter</span>().<span class="fn">max_by_key</span>(|f| f.<span class="fn">size_bytes</span>());
<span class="kw">let</span> most_recent = events.<span class="fn">iter</span>().<span class="fn">max_by_key</span>(|e| e.timestamp);
<span class="kw">let</span> shortest_name = users.<span class="fn">iter</span>().<span class="fn">min_by_key</span>(|u| u.name.<span class="fn">len</span>());</code></pre>

      <p>
        <code>max_by_key</code> and <code>min_by_key</code> let you point at a
        field or derived value and say "compare by this." No need to implement
        <code>Ord</code> on the whole struct. If you need more complex comparison
        logic (multi-field tiebreaking), use <code>max_by</code> with a full
        comparator closure instead.
      </p>

      <h3>22. The Nested Flattening</h3>

      <p>
        You have a list of things, each containing its own list. You want one flat
        list of all the sub-items.
      </p>

      <pre><code><span class="kw">let</span> all_tags: <span class="ty">Vec</span>&lt;&amp;<span class="ty">str</span>&gt; = posts.<span class="fn">iter</span>()
    .<span class="fn">flat_map</span>(|p| &amp;p.tags)
    .<span class="fn">collect</span>();</code></pre>

      <p>
        <code>flat_map</code> is <code>map</code> followed by <code>flatten</code>.
        Each element produces an iterator (or something that can become one), and
        the results are concatenated into a single stream. It's the iterator
        equivalent of a nested loop, flattened.
      </p>

      <h3>23. The Index-Aware Transformation</h3>

      <p>
        You're processing a list and you need to know each element's position --
        for numbering output, building an index, or treating the first/last element
        differently.
      </p>

      <pre><code><span class="kw">for</span> (i, line) <span class="kw">in</span> lines.<span class="fn">iter</span>().<span class="fn">enumerate</span>() {
    <span class="fn">println!</span>(<span class="str">"{:4}: {}"</span>, i + <span class="num">1</span>, line);
}

<span class="cm">// Or in a chain:</span>
<span class="kw">let</span> numbered: <span class="ty">Vec</span>&lt;<span class="ty">String</span>&gt; = items.<span class="fn">iter</span>()
    .<span class="fn">enumerate</span>()
    .<span class="fn">map</span>(|(i, item)| <span class="fn">format!</span>(<span class="str">"{}. {}"</span>, i + <span class="num">1</span>, item))
    .<span class="fn">collect</span>();</code></pre>

      <p>
        <code>enumerate()</code> wraps each element in a <code>(index, element)</code>
        tuple, starting from zero. It's the Rust equivalent of the
        "for i, item in enumerate(items)" pattern from Python.
      </p>

      <h3>24. The Collection Partition</h3>

      <p>
        You want to split one list into two: things that pass a test and things that
        fail it. Both halves matter.
      </p>

      <pre><code><span class="kw">let</span> (passing, failing): (<span class="ty">Vec</span>&lt;_&gt;, <span class="ty">Vec</span>&lt;_&gt;) = tests.<span class="fn">iter</span>()
    .<span class="fn">partition</span>(|t| t.score &gt;= <span class="num">70</span>);</code></pre>

      <p>
        <code>partition</code> takes a predicate and returns a tuple of two
        collections. Every element goes into exactly one of them. Note the type
        annotation -- Rust needs to know what kind of collections to build, since
        <code>partition</code> works with any <code>FromIterator</code> type.
      </p>

      <h3>25. The Double-Ended Extraction</h3>

      <p>
        You need the first and last elements of a collection. Not the min and max
        -- the actual first and last by position.
      </p>

      <pre><code><span class="kw">let</span> <span class="kw">mut</span> it = items.<span class="fn">iter</span>();
<span class="kw">let</span> first = it.<span class="fn">next</span>();
<span class="kw">let</span> last = it.<span class="fn">next_back</span>();</code></pre>

      <p>
        This works because <code>slice::Iter</code> implements
        <code>DoubleEndedIterator</code>, which gives you <code>next_back()</code>.
        The two calls don't interfere -- <code>next</code> pulls from the front,
        <code>next_back</code> pulls from the back. If the collection has only one
        element, <code>last</code> will be <code>None</code>.
      </p>

      <h3>26. The Pair Walk</h3>

      <p>
        You have two lists of the same length and you want to process them
        element-by-element in lockstep.
      </p>

      <pre><code><span class="kw">let</span> names = <span class="fn">vec!</span>[<span class="str">"Alice"</span>, <span class="str">"Bob"</span>, <span class="str">"Carol"</span>];
<span class="kw">let</span> scores = <span class="fn">vec!</span>[<span class="num">95</span>, <span class="num">87</span>, <span class="num">92</span>];

<span class="kw">let</span> report: <span class="ty">Vec</span>&lt;<span class="ty">String</span>&gt; = names.<span class="fn">iter</span>()
    .<span class="fn">zip</span>(scores.<span class="fn">iter</span>())
    .<span class="fn">map</span>(|(name, score)| <span class="fn">format!</span>(<span class="str">"{name}: {score}"</span>))
    .<span class="fn">collect</span>();</code></pre>

      <p>
        <code>zip</code> pairs up elements from two iterators, producing
        <code>(a, b)</code> tuples. It stops when the shorter iterator runs out --
        no panics, no padding, just a clean stop. If you need to know about the
        leftovers, look at <code>zip_longest</code> from the <code>itertools</code>
        crate.
      </p>

      <h3>27. The Chain Link</h3>

      <p>
        You have two collections of the same type and you want to process them as
        one continuous sequence.
      </p>

      <pre><code><span class="kw">let</span> defaults = <span class="fn">vec!</span>[<span class="str">"debug"</span>, <span class="str">"info"</span>];
<span class="kw">let</span> overrides = <span class="fn">vec!</span>[<span class="str">"warn"</span>, <span class="str">"error"</span>];

<span class="kw">let</span> all_levels: <span class="ty">Vec</span>&lt;_&gt; = defaults.<span class="fn">iter</span>()
    .<span class="fn">chain</span>(overrides.<span class="fn">iter</span>())
    .<span class="fn">collect</span>();
<span class="cm">// ["debug", "info", "warn", "error"]</span></code></pre>

      <p>
        <code>chain</code> appends one iterator after another. When the first runs
        out, it seamlessly switches to the second. You can chain as many as you
        want: <code>a.chain(b).chain(c)</code>. It's lazy -- nothing happens until
        you consume the chained iterator.
      </p>

      <h3>28. The Existence Probe</h3>

      <p>
        You don't need the matching element. You just need to know: does <em>any</em>
        element match? Or do <em>all</em> of them match?
      </p>

      <pre><code><span class="kw">let</span> has_errors = results.<span class="fn">iter</span>().<span class="fn">any</span>(|r| r.<span class="fn">is_err</span>());
<span class="kw">let</span> all_positive = numbers.<span class="fn">iter</span>().<span class="fn">all</span>(|&amp;n| n &gt; <span class="num">0</span>);</code></pre>

      <p>
        Both <code>any</code> and <code>all</code> short-circuit. <code>any</code>
        returns <code>true</code> the moment it finds a match and stops.
        <code>all</code> returns <code>false</code> the moment it finds a non-match
        and stops. They're the iterator equivalent of <code>||</code> and
        <code>&amp;&amp;</code> across a collection.
      </p>

      <h3>29. The Accumulator</h3>

      <p>
        You need to reduce a collection down to a single value, and the reduction
        is more complex than a simple sum or product.
      </p>

      <pre><code><span class="cm">// Build a frequency map</span>
<span class="kw">let</span> freq = words.<span class="fn">iter</span>().<span class="fn">fold</span>(<span class="ty">HashMap</span>::<span class="fn">new</span>(), |<span class="kw">mut</span> map, word| {
    *map.<span class="fn">entry</span>(word).<span class="fn">or_insert</span>(<span class="num">0</span>) += <span class="num">1</span>;
    map
});

<span class="cm">// Concatenate with a separator</span>
<span class="kw">let</span> csv = fields.<span class="fn">iter</span>().<span class="fn">fold</span>(<span class="ty">String</span>::<span class="fn">new</span>(), |<span class="kw">mut</span> acc, field| {
    <span class="kw">if</span> !acc.<span class="fn">is_empty</span>() { acc.<span class="fn">push</span>(<span class="str">','</span>); }
    acc.<span class="fn">push_str</span>(field);
    acc
});</code></pre>

      <p>
        <code>fold</code> takes an initial value (the "accumulator") and a closure
        that combines the accumulator with each element. It's the general-purpose
        reduction -- <code>sum</code>, <code>product</code>, <code>count</code>,
        <code>min</code>, and <code>max</code> are all special cases of
        <code>fold</code>. If you don't need an initial value, <code>reduce</code>
        starts with the first element instead.
      </p>

      <h3>30. The Windowed View</h3>

      <p>
        You need to look at consecutive groups of elements -- pairs, triples, or
        sliding windows of any size.
      </p>

      <pre><code><span class="kw">let</span> data = <span class="fn">vec!</span>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>];

<span class="cm">// Sliding windows of size 2</span>
<span class="kw">for</span> pair <span class="kw">in</span> data.<span class="fn">windows</span>(<span class="num">2</span>) {
    <span class="fn">println!</span>(<span class="str">"{} -> {}"</span>, pair[<span class="num">0</span>], pair[<span class="num">1</span>]);
}
<span class="cm">// 1 -> 2, 2 -> 3, 3 -> 4, 4 -> 5</span>

<span class="cm">// Fixed-size chunks (non-overlapping)</span>
<span class="kw">for</span> chunk <span class="kw">in</span> data.<span class="fn">chunks</span>(<span class="num">2</span>) {
    <span class="fn">println!</span>(<span class="str">"{:?}"</span>, chunk);
}
<span class="cm">// [1, 2], [3, 4], [5]</span></code></pre>

      <p>
        <code>windows</code> gives you overlapping slices -- every contiguous group
        of <em>n</em> elements. <code>chunks</code> gives you non-overlapping
        slices -- the list cut into pieces of size <em>n</em> (the last one might
        be shorter). Both return slices, not copies.
      </p>

      <h3>31. The Unique Run</h3>

      <p>
        You have a sorted (or partially sorted) list and you want to remove
        consecutive duplicates.
      </p>

      <pre><code><span class="kw">let</span> <span class="kw">mut</span> data = <span class="fn">vec!</span>[<span class="num">1</span>, <span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">3</span>, <span class="num">3</span>, <span class="num">4</span>];
data.<span class="fn">dedup</span>();
<span class="cm">// [1, 2, 3, 4]</span>

<span class="cm">// Dedup by a key (e.g., ignore case)</span>
<span class="kw">let</span> <span class="kw">mut</span> words = <span class="fn">vec!</span>[<span class="str">"Hello"</span>, <span class="str">"hello"</span>, <span class="str">"World"</span>, <span class="str">"world"</span>];
words.<span class="fn">dedup_by_key</span>(|s| s.<span class="fn">to_lowercase</span>());
<span class="cm">// ["Hello", "World"]</span></code></pre>

      <p>
        <code>dedup</code> removes consecutive duplicates in place. It doesn't sort
        first -- it only collapses <em>runs</em> of identical values. If you need
        globally unique values, sort first, then dedup. Or use a <code>HashSet</code>
        if order doesn't matter.
      </p>

      <h3>32. The Position Finder</h3>

      <p>
        You don't need the element itself. You need to know <em>where</em> it is.
      </p>

      <pre><code><span class="kw">let</span> idx = haystack.<span class="fn">iter</span>().<span class="fn">position</span>(|&amp;x| x == needle);
<span class="cm">// Some(3) or None</span>

<span class="kw">let</span> last_idx = haystack.<span class="fn">iter</span>().<span class="fn">rposition</span>(|&amp;x| x == needle);
<span class="cm">// searches from the end</span></code></pre>

      <p>
        <code>position</code> returns the index of the first match.
        <code>rposition</code> returns the index of the last match (searching
        backward). Both return <code>Option&lt;usize&gt;</code> --
        <code>None</code> if no element matches. These are the iterator equivalent
        of <code>indexOf</code> from other languages, but with a predicate instead
        of just equality.
      </p>

      <h2>IV. Composition</h2>

      <p>
        These patterns are about combining operations cleanly -- chaining fallible
        operations, injecting side effects without breaking chains, and flipping
        container types to match what the surrounding code expects.
      </p>

      <h3>33. The Fallible Map</h3>

      <p>
        You have a <code>Result</code> and you want to run another operation that
        could also fail. If you use <code>map</code>, you end up with
        <code>Result&lt;Result&lt;T, E&gt;, E&gt;</code> -- a nested mess. You
        want flat chaining.
      </p>

      <pre><code><span class="kw">let</span> content = <span class="fn">find_file</span>(name)
    .<span class="fn">and_then</span>(|path| <span class="fn">read_to_string</span>(path))?;</code></pre>

      <p>
        <code>and_then</code> is the monadic bind for <code>Result</code> (and
        <code>Option</code>). If the first operation succeeds, it feeds the value
        to the next function. If it fails, it short-circuits with the error. It's
        <code>map</code> but the closure itself returns a <code>Result</code>, and
        the nesting is flattened automatically.
      </p>

      <p>
        On <code>Option</code>, <code>and_then</code> does the same thing -- it's
        how you chain functions that return <code>Option</code> without ending up
        with <code>Option&lt;Option&lt;T&gt;&gt;</code>.
      </p>

      <h3>34. The In-Place Wrapper Removal</h3>

      <p>
        You used a <code>BufReader</code>, a <code>GzDecoder</code>, or some other
        wrapper type to add behavior to an inner resource. Now you're done with the
        wrapper and want the original back.
      </p>

      <pre><code><span class="kw">let</span> file = buf_reader.<span class="fn">into_inner</span>();
<span class="kw">let</span> socket = tls_stream.<span class="fn">into_inner</span>();</code></pre>

      <p>
        <code>into_inner()</code> is the standard Rust name for "give me the thing
        inside this wrapper." The <code>into_</code> prefix tells you it consumes
        the wrapper. Any buffered data is <em>not</em> flushed -- if that matters,
        call <code>flush()</code> first.
      </p>

      <h3>35. The Peek and Poke</h3>

      <p>
        You're building a long method chain and something isn't working. You want to
        see what's flowing through at a specific point without breaking the chain.
      </p>

      <pre><code><span class="kw">let</span> total = items.<span class="fn">iter</span>()
    .<span class="fn">filter</span>(|x| x.<span class="fn">is_valid</span>())
    .<span class="fn">inspect</span>(|x| <span class="fn">eprintln!</span>(<span class="str">"after filter: {x:?}"</span>))
    .<span class="fn">map</span>(|x| x.<span class="fn">value</span>())
    .<span class="fn">inspect</span>(|v| <span class="fn">eprintln!</span>(<span class="str">"after map: {v}"</span>))
    .<span class="fn">sum</span>::&lt;<span class="ty">i32</span>&gt;();</code></pre>

      <p>
        <code>inspect</code> passes a reference to each element to a closure, then
        passes the element through unchanged. It's <code>println</code>-debugging
        for iterator chains. In production code, you'll see it with logging instead
        of printing.
      </p>

      <p>
        On <code>Result</code>, there's <code>inspect</code> and
        <code>inspect_err</code> for peeking at the success and error sides
        independently.
      </p>

      <h3>36. The Type Flip</h3>

      <p>
        You have an <code>Option&lt;Result&lt;T, E&gt;&gt;</code> -- maybe from a
        function that optionally does something fallible. But your function returns
        <code>Result</code>, so you want
        <code>Result&lt;Option&lt;T&gt;, E&gt;</code> instead, so you can use
        <code>?</code> on the outer layer.
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">get_config_value</span>(key: &amp;<span class="ty">str</span>) -&gt; <span class="ty">Result</span>&lt;<span class="ty">Option</span>&lt;<span class="ty">String</span>&gt;, <span class="ty">ConfigError</span>&gt; {
    <span class="kw">let</span> maybe_raw: <span class="ty">Option</span>&lt;<span class="ty">Result</span>&lt;<span class="ty">String</span>, <span class="ty">ConfigError</span>&gt;&gt; = map.<span class="fn">get</span>(key).<span class="fn">map</span>(parse);
    maybe_raw.<span class="fn">transpose</span>()
    <span class="cm">// Option&lt;Result&lt;T, E&gt;&gt; -> Result&lt;Option&lt;T&gt;, E&gt;</span>
}</code></pre>

      <p>
        <code>transpose</code> swaps the container types. If the <code>Option</code>
        is <code>None</code>, you get <code>Ok(None)</code>. If it's
        <code>Some(Ok(v))</code>, you get <code>Ok(Some(v))</code>. If it's
        <code>Some(Err(e))</code>, you get <code>Err(e)</code>. It works in the
        other direction too --
        <code>Result&lt;Option&lt;T&gt;, E&gt;</code> back to
        <code>Option&lt;Result&lt;T, E&gt;&gt;</code>.
      </p>

      <h3>37. The Lazy Default</h3>

      <p>
        If a value is missing, you need a default -- but that default involves a
        heap allocation or a computation you don't want to do unless you have to.
      </p>

      <pre><code><span class="cm">// This allocates every time, even when the Option is Some:</span>
<span class="kw">let</span> name = opt_name.<span class="fn">unwrap_or</span>(<span class="ty">String</span>::<span class="fn">from</span>(<span class="str">"Anonymous"</span>));

<span class="cm">// This only allocates when the Option is None:</span>
<span class="kw">let</span> name = opt_name.<span class="fn">unwrap_or_else</span>(|| <span class="ty">String</span>::<span class="fn">from</span>(<span class="str">"Anonymous"</span>));</code></pre>

      <p>
        The <code>_or</code> vs <code>_or_else</code> distinction is one of Rust's
        core naming conventions (covered in the
        <a href="rust-idioms-in-plain-english.html">companion post</a>). Eager vs
        lazy. Value vs closure. Whenever the fallback involves allocation, I/O, or
        anything more than returning a literal, reach for the <code>_else</code>
        variant.
      </p>

      <h3>38. The Slot Machine</h3>

      <p>
        You're building up a <code>HashMap</code> and you need to handle the
        "insert if missing, update if present" logic cleanly. The entry API gives
        you a handle to a slot, and then you decide what to do with it.
      </p>

      <pre><code><span class="kw">use</span> std::collections::<span class="ty">HashMap</span>;

<span class="kw">let</span> <span class="kw">mut</span> counts: <span class="ty">HashMap</span>&lt;&amp;<span class="ty">str</span>, <span class="ty">i32</span>&gt; = <span class="ty">HashMap</span>::<span class="fn">new</span>();

<span class="kw">for</span> word <span class="kw">in</span> words {
    *counts.<span class="fn">entry</span>(word).<span class="fn">or_insert</span>(<span class="num">0</span>) += <span class="num">1</span>;
}

<span class="cm">// or_insert_with for expensive defaults:</span>
<span class="kw">let</span> <span class="kw">mut</span> cache: <span class="ty">HashMap</span>&lt;<span class="ty">String</span>, <span class="ty">Vec</span>&lt;<span class="ty">Data</span>&gt;&gt; = <span class="ty">HashMap</span>::<span class="fn">new</span>();
<span class="kw">let</span> items = cache.<span class="fn">entry</span>(key.<span class="fn">clone</span>())
    .<span class="fn">or_insert_with</span>(|| <span class="fn">load_from_disk</span>(&amp;key));</code></pre>

      <p>
        <code>entry()</code> returns an <code>Entry</code> enum -- either
        <code>Occupied</code> or <code>Vacant</code>. Then <code>or_insert</code>
        fills the vacant slot, or <code>or_insert_with</code> computes the value
        lazily. The whole thing gives you a mutable reference to the value, whether
        it was just inserted or already there. It's a single hash lookup instead of
        the two (check then insert) you'd need otherwise.
      </p>

      <h3>39. The Turbofish</h3>

      <p>
        Rust can usually infer types, but sometimes it can't. You need to tell it
        explicitly, and the syntax for that looks like a fish:
        <code>::&lt;Type&gt;</code>.
      </p>

      <pre><code><span class="kw">let</span> x = <span class="str">"42"</span>.<span class="fn">parse</span>::&lt;<span class="ty">i32</span>&gt;()?;
<span class="kw">let</span> nums = <span class="fn">vec!</span>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="fn">into_iter</span>().<span class="fn">collect</span>::&lt;<span class="ty">HashSet</span>&lt;_&gt;&gt;();
<span class="kw">let</span> total = values.<span class="fn">iter</span>().<span class="fn">sum</span>::&lt;<span class="ty">f64</span>&gt;();</code></pre>

      <p>
        The turbofish appears when a method is generic and the return type isn't
        constrained by context. <code>parse</code> can return anything that
        implements <code>FromStr</code>, <code>collect</code> can build anything
        that implements <code>FromIterator</code>, and <code>sum</code> can return
        any numeric type. The turbofish disambiguates. The alternative is a type
        annotation on the variable: <code>let x: i32 = "42".parse()?;</code> --
        same effect, different style.
      </p>

      <h3>40. The Scope Guard</h3>

      <p>
        You need to run cleanup code when a value is dropped, regardless of whether
        the function returns normally or panics. Rust's <code>Drop</code> trait is
        the tool, and it works even on early returns from <code>?</code>.
      </p>

      <pre><code><span class="kw">struct</span> <span class="ty">TempFile</span>(<span class="ty">PathBuf</span>);

<span class="kw">impl</span> <span class="ty">Drop</span> <span class="kw">for</span> <span class="ty">TempFile</span> {
    <span class="kw">fn</span> <span class="fn">drop</span>(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
        <span class="kw">let</span> _ = std::fs::<span class="fn">remove_file</span>(&amp;<span class="kw">self</span>.<span class="num">0</span>);
    }
}

<span class="kw">fn</span> <span class="fn">process</span>() -&gt; <span class="ty">Result</span>&lt;(), <span class="ty">Error</span>&gt; {
    <span class="kw">let</span> tmp = <span class="ty">TempFile</span>(<span class="fn">create_temp_file</span>()?);
    <span class="fn">do_something_fallible</span>()?;   <span class="cm">// if this fails, tmp is still cleaned up</span>
    <span class="fn">do_another_thing</span>()?;        <span class="cm">// same here</span>
    <span class="ty">Ok</span>(())
    <span class="cm">// tmp dropped here on success</span>
}</code></pre>

      <p>
        This is Rust's answer to <code>try/finally</code>, <code>defer</code>, and
        RAII. The <code>Drop</code> implementation runs when the value goes out of
        scope -- whether that's at the end of the function, after a <code>?</code>
        early return, or during a panic unwind. You don't call it. You can't forget
        it.
      </p>

      <h2>Putting It All Together</h2>

      <p>
        These patterns combine. Here's a real-world example that uses several at once:
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">load_user_configs</span>(paths: &amp;[<span class="ty">PathBuf</span>]) -&gt; <span class="ty">Result</span>&lt;<span class="ty">Vec</span>&lt;<span class="ty">Config</span>&gt;, <span class="ty">AppError</span>&gt; {
    paths.<span class="fn">iter</span>()
        .<span class="fn">enumerate</span>()                                          <span class="cm">// #23: know the index</span>
        .<span class="fn">map</span>(|(i, path)| {
            std::fs::<span class="fn">read_to_string</span>(path)                     <span class="cm">// fallible</span>
                .<span class="fn">map_err</span>(|e| <span class="ty">AppError</span>::FileRead {             <span class="cm">// #4: specific context</span>
                    index: i,
                    path: path.<span class="fn">clone</span>(),
                    source: e,
                })
                .<span class="fn">and_then</span>(|text| {                            <span class="cm">// #33: chain fallible ops</span>
                    <span class="fn">parse_config</span>(&amp;text)
                        .<span class="fn">map_err</span>(|e| <span class="ty">AppError</span>::Parse {        <span class="cm">// #4 again</span>
                            index: i,
                            path: path.<span class="fn">clone</span>(),
                            source: e,
                        })
                })
        })
        .<span class="fn">collect</span>()                                            <span class="cm">// #1: success or bail</span>
}</code></pre>

      <p>
        Six patterns, one function, zero unwraps. The error handling is precise:
        every failure says exactly which file and which stage. The success path
        reads top-to-bottom without nesting.
      </p>

      <p>
        That's what "thinking in Rust" looks like. It's not about memorizing forty
        methods. It's about recognizing that each one is a small, named decision --
        and that the right combination of small decisions makes the big picture clean.
      </p>

    </article>
  </main>

  <footer>
    <div class="container">
      MIT - Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
