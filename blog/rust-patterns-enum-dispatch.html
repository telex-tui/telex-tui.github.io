<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #14: Enum Dispatch vs Trait Objects - Telex</title>
  <meta name="description" content="Two ways to do polymorphism in Rust: enums with match for closed sets of types, trait objects for open sets. Choose based on your extension story.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #14: Enum Dispatch vs Trait Objects</h1>
      <div class="post-meta">July 2026</div>
      <p class="series-nav">Post 14 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        You have several types that all need to do the same thing &mdash; like different
        shapes that can each calculate their area. In most languages, you'd use an interface
        or a base class. Rust gives you two options: enums and trait objects. They solve the
        same problem in opposite ways, and picking the wrong one makes the code harder to
        change later.
      </p>

      <h2>Approach 1: Enum dispatch</h2>

      <pre><code><span class="kw">enum</span> <span class="ty">Shape</span> {
    <span class="ty">Circle</span> { radius: <span class="ty">f64</span> },
    <span class="ty">Rect</span> { width: <span class="ty">f64</span>, height: <span class="ty">f64</span> },
    <span class="ty">Triangle</span> { base: <span class="ty">f64</span>, height: <span class="ty">f64</span> },
}

<span class="kw">impl</span> <span class="ty">Shape</span> {
    <span class="kw">fn</span> <span class="fn">area</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">f64</span> {
        <span class="kw">match</span> <span class="kw">self</span> {
            <span class="ty">Shape</span>::<span class="ty">Circle</span> { radius } =&gt;
                std::<span class="ty">f64</span>::consts::<span class="ty">PI</span> * radius * radius,
            <span class="ty">Shape</span>::<span class="ty">Rect</span> { width, height } =&gt;
                width * height,
            <span class="ty">Shape</span>::<span class="ty">Triangle</span> { base, height } =&gt;
                <span class="num">0.5</span> * base * height,
        }
    }

    <span class="kw">fn</span> <span class="fn">perimeter</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">f64</span> {
        <span class="kw">match</span> <span class="kw">self</span> {
            <span class="ty">Shape</span>::<span class="ty">Circle</span> { radius } =&gt;
                <span class="num">2.0</span> * std::<span class="ty">f64</span>::consts::<span class="ty">PI</span> * radius,
            <span class="ty">Shape</span>::<span class="ty">Rect</span> { width, height } =&gt;
                <span class="num">2.0</span> * (width + height),
            <span class="ty">Shape</span>::<span class="ty">Triangle</span> { base, height } =&gt; {
                <span class="kw">let</span> side = (base * base / <span class="num">4.0</span> + height * height).<span class="fn">sqrt</span>();
                base + <span class="num">2.0</span> * side
            }
        }
    }
}</code></pre>

      <p>
        <strong>Adding a new operation</strong> (like <code>perimeter</code>) is easy: write
        one new method with a <code>match</code> that covers every variant in one place.
      </p>
      <p>
        <strong>Adding a new variant</strong> (like <code>Pentagon</code>) means you have to
        add a new arm to every <code>match</code> in every method. Exhaustive matching
        gives you a compile error for each method you haven't updated yet. But the
        changes are spread across the whole file.
      </p>

      <h2>Approach 2: Trait objects</h2>

      <pre><code><span class="kw">trait</span> <span class="ty">Shape</span> {
    <span class="kw">fn</span> <span class="fn">area</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">f64</span>;
    <span class="kw">fn</span> <span class="fn">perimeter</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">f64</span>;
}

<span class="kw">struct</span> <span class="ty">Circle</span> { radius: <span class="ty">f64</span> }
<span class="kw">struct</span> <span class="ty">Rect</span> { width: <span class="ty">f64</span>, height: <span class="ty">f64</span> }

<span class="kw">impl</span> <span class="ty">Shape</span> <span class="kw">for</span> <span class="ty">Circle</span> {
    <span class="kw">fn</span> <span class="fn">area</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">f64</span> {
        std::<span class="ty">f64</span>::consts::<span class="ty">PI</span> * <span class="kw">self</span>.radius * <span class="kw">self</span>.radius
    }
    <span class="kw">fn</span> <span class="fn">perimeter</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">f64</span> {
        <span class="num">2.0</span> * std::<span class="ty">f64</span>::consts::<span class="ty">PI</span> * <span class="kw">self</span>.radius
    }
}

<span class="kw">impl</span> <span class="ty">Shape</span> <span class="kw">for</span> <span class="ty">Rect</span> {
    <span class="kw">fn</span> <span class="fn">area</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">f64</span> { <span class="kw">self</span>.width * <span class="kw">self</span>.height }
    <span class="kw">fn</span> <span class="fn">perimeter</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">f64</span> { <span class="num">2.0</span> * (<span class="kw">self</span>.width + <span class="kw">self</span>.height) }
}

<span class="cm">// Usage with trait objects:</span>
<span class="kw">let</span> shapes: <span class="ty">Vec</span>&lt;<span class="ty">Box</span>&lt;<span class="kw">dyn</span> <span class="ty">Shape</span>&gt;&gt; = <span class="fn">vec!</span>[
    <span class="ty">Box</span>::<span class="fn">new</span>(<span class="ty">Circle</span> { radius: <span class="num">5.0</span> }),
    <span class="ty">Box</span>::<span class="fn">new</span>(<span class="ty">Rect</span> { width: <span class="num">3.0</span>, height: <span class="num">4.0</span> }),
];</code></pre>

      <p>
        <strong>Adding a new variant</strong> (a new struct that implements <code>Shape</code>)
        is easy: write the struct and its impl block. You don't touch any existing code.
      </p>
      <p>
        <strong>Adding a new operation</strong> (a new method on the trait) is hard: every
        struct that implements the trait has to be updated. If the trait lives in a library,
        adding a method breaks all downstream code.
      </p>

      <h2>The expression problem</h2>

      <p>
        This tradeoff shows up in every language:
      </p>
      <ul>
        <li><strong>Enums:</strong> easy to add operations, hard to add variants</li>
        <li><strong>Trait objects:</strong> easy to add variants, hard to add operations</li>
      </ul>
      <p>
        Neither is always better. The question is: how will your code grow? Will you mostly
        add new types, or mostly add new operations?
      </p>

      <h2>VTable economics</h2>

      <p>
        Enum dispatch resolves at compile time. The compiler sees the
        <code>match</code>, knows every variant, and can inline each arm's code
        directly. No heap allocation, no pointer indirection, no vtable lookup.
      </p>
      <p>
        Trait objects use dynamic dispatch: each call loads a function pointer from
        a vtable and jumps to it. That's one extra memory read per call, plus the
        object itself usually lives behind a <code>Box</code> on the heap. The
        indirection prevents the compiler from inlining the method body.
      </p>
      <p>
        But the tradeoff isn't just "static is faster." Enum dispatch causes
        <strong>code bloat</strong>: the compiler emits specialized code for every
        variant in every match arm. With 20 variants and 10 methods, that's 200
        inlined code paths. In large binaries, this inflates the instruction cache
        footprint — more code means more I-cache misses, which can actually make
        the program slower than the vtable approach. Trait objects keep the code
        compact: one call site, one indirect jump.
      </p>
      <p>
        In practice: enum dispatch wins when you have a small number of variants
        (under ~20) and the match arms are small. Trait objects win when the set of
        types is large, open-ended, or the method bodies are substantial enough that
        inlining them everywhere would bloat the binary. Profile both if it matters.
      </p>

      <h2>Telex's choice</h2>

      <p>
        Telex uses an enum for its <code>View</code> type:
      </p>

      <pre><code><span class="kw">enum</span> <span class="ty">View</span> {
    <span class="ty">Text</span>(<span class="ty">String</span>),
    <span class="ty">Container</span> { children: <span class="ty">Vec</span>&lt;<span class="ty">View</span>&gt; },
    <span class="ty">Button</span> { label: <span class="ty">String</span>, on_click: <span class="ty">Rc</span>&lt;<span class="kw">dyn</span> <span class="ty">Fn</span>()&gt; },
    <span class="cm">// ... other built-in widgets</span>
}</code></pre>

      <p>
        The framework controls which widget types exist &mdash; users don't add new ones.
        That's a fixed list of variants. Meanwhile, new operations on those widgets
        (rendering, diffing, layout) get added more often than new widget types. That makes
        enum dispatch the right fit. See
        <a href="designing-a-tui-framework-in-rust.html">Designing a TUI Framework &mdash;
        Part 1</a> for the full reasoning.
      </p>

      <h2>What does this cost?</h2>

      <p>
        Enum dispatch: the enum is sized to its largest variant plus a discriminant
        (1–8 bytes depending on variant count). Match dispatch compiles to a jump
        table or branch chain — the cost is a branch prediction, not a pointer
        chase. No heap allocation. The trade is code size: each match arm is inlined.
      </p>
      <p>
        Trait objects: one heap allocation per object (the <code>Box</code>), plus a
        vtable pointer (one usize) alongside the data pointer. Each method call is
        an indirect jump through the vtable — roughly the cost of a virtual method
        call in C++. Without trait objects, you'd need unsafe function pointer tables
        and manual type erasure — which is exactly what a vtable is.
      </p>

      <h2>When to use which</h2>

      <ul>
        <li><strong>Enum dispatch</strong> when you know all the variants, your crate controls
          them, and you'll add new operations more often than new types. Also when you need
          the performance of static dispatch.</li>
        <li><strong>Trait objects</strong> when your users define the types: plugin systems,
          user-extensible components, anything where downstream crates write the
          implementations. When you don't know ahead of time how many types there will be.</li>
      </ul>
      <p>
        The deciding question: <em>who writes the concrete types?</em> If it's you, use an
        enum. If it's your users, use a trait.
      </p>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-interior-mutability.html">#1: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#2: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><a href="rust-patterns-cow.html">#6: Cow &mdash; Borrow or Own</a></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#7: Lifetime Annotations</a></li>
          <li><a href="rust-patterns-static-clone.html">#8: &rsquo;static + Clone</a></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-newtype.html">#11: Newtype</a></li>
          <li><a href="rust-patterns-typestate.html">#12: Typestate</a></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><strong>#14: Enum Dispatch vs Trait Objects</strong></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#16: Error Handling</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#19: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
