<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #1: Interior Mutability - Telex</title>
  <meta name="description" content="When you need to mutate behind an immutable interface, RefCell gives you runtime borrow checking. The first pattern every Rust developer hits.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #1: Interior Mutability</h1>
      <div class="post-meta">March 2026</div>
      <p class="series-nav">Post 1 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        You have a struct with a <code>HashMap</code> field that you use for caching, and it
        gets passed around by shared reference. Inside a method that takes <code>&amp;self</code>,
        you need to insert into that <code>HashMap</code> &mdash; and the compiler says no.
        This is the first wall.
      </p>

      <h2>The motivation</h2>

      <p>
        Say you have a configuration loader that parses files on demand and stores the
        results in a <code>HashMap</code> so it doesn't have to parse them again. Callers only need
        a shared reference &mdash; they're reading configuration, not modifying the loader
        itself. But the loader needs to insert into its <code>HashMap</code>.
      </p>

      <pre><code><span class="kw">use</span> std::collections::<span class="ty">HashMap</span>;

<span class="kw">struct</span> <span class="ty">ConfigLoader</span> {
    cache: <span class="ty">HashMap</span>&lt;<span class="ty">String</span>, <span class="ty">String</span>&gt;,
}

<span class="kw">impl</span> <span class="ty">ConfigLoader</span> {
    <span class="kw">fn</span> <span class="fn">get</span>(&amp;<span class="kw">self</span>, key: &amp;<span class="kw">str</span>) -&gt; <span class="ty">Option</span>&lt;&amp;<span class="ty">String</span>&gt; {
        <span class="kw">if</span> !<span class="kw">self</span>.cache.<span class="fn">contains_key</span>(key) {
            <span class="kw">let</span> value = <span class="kw">self</span>.<span class="fn">load_from_disk</span>(key);
            <span class="kw">self</span>.cache.<span class="fn">insert</span>(key.<span class="fn">to_string</span>(), value); <span class="cm">// ERROR</span>
        }
        <span class="kw">self</span>.cache.<span class="fn">get</span>(key)
    }
}</code></pre>

      <p>
        The compiler rejects this:
      </p>

      <pre><code><span class="cm">error[E0596]: cannot borrow `self.cache` as mutable,
              as it is behind a `&` reference</span></code></pre>

      <p>
        The method takes <code>&amp;self</code>, which is a shared, read-only reference. You
        can't write through it. That's not a suggestion &mdash; the entire borrow system
        depends on that guarantee.
      </p>

      <h2>Why the compiler does this</h2>

      <p>
        Rust's safety comes from two rules: if you have a <code>&amp;T</code>, nobody is
        changing <code>T</code> right now. If you have a <code>&amp;mut T</code>, nobody else
        can see <code>T</code> right now. These two rules prevent data races, iterator
        invalidation, and use-after-free &mdash; all at compile time, with no runtime cost.
      </p>
      <p>
        The problem is that the <code>HashMap</code> really does need to change, even though
        from the outside <code>get()</code> looks like a read. Caching is an implementation
        detail the caller shouldn't care about. But the type system doesn't know that &mdash;
        it sees a write through a shared reference and says no.
      </p>

      <h2>The pattern: <code>RefCell&lt;T&gt;</code></h2>

      <p>
        <code>RefCell&lt;T&gt;</code> moves borrow checking from compile time to runtime.
        You wrap a value in it, then call <code>.borrow()</code> to read and
        <code>.borrow_mut()</code> to write. The same rules apply &mdash; many readers or one
        writer, never both &mdash; but they're checked when the code runs instead of when it
        compiles.
      </p>

      <pre><code><span class="kw">use</span> std::cell::<span class="ty">RefCell</span>;
<span class="kw">use</span> std::collections::<span class="ty">HashMap</span>;

<span class="kw">struct</span> <span class="ty">ConfigLoader</span> {
    cache: <span class="ty">RefCell</span>&lt;<span class="ty">HashMap</span>&lt;<span class="ty">String</span>, <span class="ty">String</span>&gt;&gt;,
}

<span class="kw">impl</span> <span class="ty">ConfigLoader</span> {
    <span class="kw">fn</span> <span class="fn">get</span>(&amp;<span class="kw">self</span>, key: &amp;<span class="kw">str</span>) -&gt; <span class="ty">Option</span>&lt;<span class="ty">String</span>&gt; {
        <span class="kw">if</span> !<span class="kw">self</span>.cache.<span class="fn">borrow</span>().<span class="fn">contains_key</span>(key) {
            <span class="kw">let</span> value = <span class="kw">self</span>.<span class="fn">load_from_disk</span>(key);
            <span class="kw">self</span>.cache.<span class="fn">borrow_mut</span>().<span class="fn">insert</span>(key.<span class="fn">to_string</span>(), value);
        }
        <span class="kw">self</span>.cache.<span class="fn">borrow</span>().<span class="fn">get</span>(key).<span class="fn">cloned</span>()
    }
}</code></pre>

      <p>
        The method still takes <code>&amp;self</code>. The <code>HashMap</code> is wrapped in a
        <code>RefCell</code>, so you can write to it even through a shared reference. The
        compiler allows this because <code>RefCell</code> promises to enforce the borrow rules
        itself, at runtime.
      </p>

      <h2>What happens at runtime</h2>

      <p>
        Inside, <code>RefCell</code> keeps a counter. Each <code>.borrow()</code> increments
        it; dropping the returned guard decrements it. <code>.borrow_mut()</code> checks that
        the counter is zero &mdash; meaning nobody else is borrowing &mdash; and sets a flag.
        If you break the rules, like calling <code>.borrow_mut()</code> while a
        <code>.borrow()</code> guard is still alive, it panics.
      </p>

      <pre><code><span class="kw">let</span> cell = <span class="ty">RefCell</span>::<span class="fn">new</span>(<span class="num">42</span>);

<span class="kw">let</span> a = cell.<span class="fn">borrow</span>();     <span class="cm">// shared borrow — fine</span>
<span class="kw">let</span> b = cell.<span class="fn">borrow</span>();     <span class="cm">// second shared borrow — fine</span>
<span class="kw">let</span> c = cell.<span class="fn">borrow_mut</span>(); <span class="cm">// PANIC: already borrowed</span></code></pre>

      <p>
        That panic isn't a bug in <code>RefCell</code> (though it probably means one in your
        code). It's <code>RefCell</code> enforcing the same rule the compiler would have
        caught at compile time: you can't have a mutable borrow while shared borrows exist.
      </p>

      <h2>The tradeoff</h2>

      <p>
        With <code>RefCell</code>, you trade compile-time checking for runtime checking.
        The compiler won't catch conflicting borrows anymore &mdash; you'll find out when
        your code panics. The borrow rules still apply; they just moved from the compiler
        to the running program.
      </p>
      <p>
        The runtime cost is small &mdash; just checking an integer on each borrow. The real
        cost is the risk of panics. If you can take <code>&amp;mut self</code> instead and let
        the compiler check everything statically, do that. Use <code>RefCell</code> when
        callers need shared access but the struct still needs to write to one of its fields.
      </p>

      <h2>When to use it</h2>

      <p>
        <strong>Good uses:</strong>
      </p>
      <ul>
        <li>A <code>HashMap</code> used for caching behind an <code>&amp;self</code> method (the example above)</li>
        <li>Fields that compute their value the first time they're accessed, then store it</li>
        <li>A <code>Vec</code> of observers that gets modified even though the subject is shared</li>
        <li>Any field that changes as an implementation detail, invisible to callers</li>
      </ul>
      <p>
        <strong>When not to use it:</strong>
      </p>
      <ul>
        <li>If you can change the method to take <code>&amp;mut self</code>, do that &mdash;
          the compiler checks everything for you and there's no overhead</li>
        <li>If you need thread safety, <code>RefCell</code> won't work &mdash; it's
          <code>!Sync</code>. Use <code>Mutex</code> or <code>RwLock</code> instead
          (<a href="rust-patterns-arc-mutex.html">#17</a>)</li>
      </ul>

      <h2>What comes next</h2>

      <p>
        <code>RefCell</code> lets you write to a field through <code>&amp;self</code>, but
        only one variable can own the struct. When multiple parts of your program need to
        hold onto the same data, you need <code>Rc</code> &mdash; which is
        <a href="rust-patterns-shared-ownership.html">the next post</a>. And when you
        need multiple owners who can <em>also</em> write,
        <a href="rust-patterns-rc-refcell.html">#3</a> puts the two together.
      </p>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><strong>#1: Interior Mutability</strong></li>
          <li><a href="rust-patterns-shared-ownership.html">#2: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><a href="rust-patterns-cow.html">#6: Cow &mdash; Borrow or Own</a></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#7: Lifetime Annotations</a></li>
          <li><a href="rust-patterns-static-clone.html">#8: &rsquo;static + Clone</a></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-newtype.html">#11: Newtype</a></li>
          <li><a href="rust-patterns-typestate.html">#12: Typestate</a></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#16: Error Handling</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#19: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
