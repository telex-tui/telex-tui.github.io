<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #16: Error Handling - Telex</title>
  <meta name="description" content="One error pattern for libraries (thiserror for structured, matchable errors), one for applications (anyhow for convenient, context-rich errors). Know which you're writing.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #16: Error Handling with <code>?</code> + <code>thiserror</code> + <code>anyhow</code></h1>
      <div class="post-meta">July 2026</div>
      <p class="series-nav">Post 16 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        Real programs fail in many ways. A config file might be missing. A JSON payload
        might be malformed. A database might be unreachable. A network request might time
        out. Each layer of your program produces its own kind of error, and you need to
        combine them &mdash; a function that reads a file, parses it, and queries a database
        might encounter three different error types. Handling each one manually means writing
        conversion boilerplate for every combination. Rust's ecosystem has settled on two
        crates that eliminate this boilerplate: <code>thiserror</code> for libraries (where
        callers need to match on specific errors) and <code>anyhow</code> for applications
        (where errors get reported to a human).
      </p>

      <h2>The problem</h2>

      <pre><code><span class="kw">fn</span> <span class="fn">load_config</span>() -&gt; <span class="ty">Result</span>&lt;<span class="ty">Config</span>, ???&gt; {
    <span class="kw">let</span> text = std::fs::<span class="fn">read_to_string</span>(<span class="str">"config.json"</span>)?; <span class="cm">// io::Error</span>
    <span class="kw">let</span> config: <span class="ty">Config</span> = <span class="fn">serde_json::from_str</span>(&amp;text)?;   <span class="cm">// serde_json::Error</span>
    <span class="ty">Ok</span>(config)
}</code></pre>

      <p>
        Two different error types. The <code>?</code> operator needs to convert both into
        one return type. What goes in place of <code>???</code>?
      </p>

      <h2>The manual approach</h2>

      <pre><code><span class="kw">enum</span> <span class="ty">ConfigError</span> {
    <span class="ty">Io</span>(std::io::<span class="ty">Error</span>),
    <span class="ty">Parse</span>(serde_json::<span class="ty">Error</span>),
}

<span class="kw">impl</span> std::fmt::<span class="ty">Display</span> <span class="kw">for</span> <span class="ty">ConfigError</span> {
    <span class="kw">fn</span> <span class="fn">fmt</span>(&amp;<span class="kw">self</span>, f: &amp;<span class="kw">mut</span> std::fmt::<span class="ty">Formatter</span>) -&gt; std::fmt::<span class="ty">Result</span> {
        <span class="kw">match</span> <span class="kw">self</span> {
            <span class="ty">ConfigError</span>::<span class="ty">Io</span>(e) =&gt; <span class="fn">write!</span>(f, <span class="str">"IO error: {e}"</span>),
            <span class="ty">ConfigError</span>::<span class="ty">Parse</span>(e) =&gt; <span class="fn">write!</span>(f, <span class="str">"parse error: {e}"</span>),
        }
    }
}

<span class="kw">impl</span> <span class="ty">From</span>&lt;std::io::<span class="ty">Error</span>&gt; <span class="kw">for</span> <span class="ty">ConfigError</span> {
    <span class="kw">fn</span> <span class="fn">from</span>(e: std::io::<span class="ty">Error</span>) -&gt; <span class="kw">Self</span> { <span class="ty">ConfigError</span>::<span class="ty">Io</span>(e) }
}

<span class="kw">impl</span> <span class="ty">From</span>&lt;serde_json::<span class="ty">Error</span>&gt; <span class="kw">for</span> <span class="ty">ConfigError</span> {
    <span class="kw">fn</span> <span class="fn">from</span>(e: serde_json::<span class="ty">Error</span>) -&gt; <span class="kw">Self</span> { <span class="ty">ConfigError</span>::<span class="ty">Parse</span>(e) }
}</code></pre>

      <p>
        This works, but it's 20 lines of boilerplate per error type. Add a database layer
        and an HTTP layer and you're writing more error plumbing than actual logic.
      </p>

      <h2><code>thiserror</code> &mdash; for libraries</h2>

      <p>
        <code>thiserror</code> is a derive macro that generates the <code>Display</code> and
        <code>From</code> impls:
      </p>

      <pre><code><span class="kw">use</span> thiserror::<span class="ty">Error</span>;

<span class="kw">#[derive(Error, Debug)]</span>
<span class="kw">enum</span> <span class="ty">ConfigError</span> {
    <span class="kw">#[error("failed to read config file")]</span>
    <span class="ty">Io</span>(<span class="kw">#[from]</span> std::io::<span class="ty">Error</span>),

    <span class="kw">#[error("failed to parse config")]</span>
    <span class="ty">Parse</span>(<span class="kw">#[from]</span> serde_json::<span class="ty">Error</span>),
}</code></pre>

      <p>
        The <code>#[error("...")]</code> attribute generates the <code>Display</code> impl.
        The <code>#[from]</code> attribute generates the <code>From</code> impl. What was
        20 lines is now 8, and the intent is clear.
      </p>
      <p>
        The key feature: <strong>callers can match on variants</strong>.
      </p>

      <pre><code><span class="kw">match</span> <span class="fn">load_config</span>() {
    <span class="ty">Ok</span>(config) =&gt; { <span class="cm">/* use config */</span> }
    <span class="ty">Err</span>(<span class="ty">ConfigError</span>::<span class="ty">Io</span>(e)) <span class="kw">if</span> e.<span class="fn">kind</span>() == <span class="ty">ErrorKind</span>::<span class="ty">NotFound</span> =&gt; {
        <span class="cm">// file missing — use defaults</span>
    }
    <span class="ty">Err</span>(e) =&gt; <span class="kw">return</span> <span class="ty">Err</span>(e.<span class="fn">into</span>()),
}</code></pre>

      <p>
        This is why <code>thiserror</code> is for libraries: the code calling your
        library can match on specific error cases and decide what to do. The error type
        is part of your API.
      </p>

      <h2><code>anyhow</code> &mdash; for applications</h2>

      <p>
        In a binary (not a library), you often don't need to match on error variants. You
        just want to bubble errors up with context, then display them to the user.
        <code>anyhow</code> makes this trivial:
      </p>

      <pre><code><span class="kw">use</span> anyhow::{<span class="ty">Context</span>, <span class="ty">Result</span>};

<span class="kw">fn</span> <span class="fn">load_config</span>() -&gt; <span class="ty">Result</span>&lt;<span class="ty">Config</span>&gt; {
    <span class="kw">let</span> text = std::fs::<span class="fn">read_to_string</span>(<span class="str">"config.json"</span>)
        .<span class="fn">context</span>(<span class="str">"failed to read config file"</span>)?;
    <span class="kw">let</span> config = <span class="fn">serde_json::from_str</span>(&amp;text)
        .<span class="fn">context</span>(<span class="str">"failed to parse config"</span>)?;
    <span class="ty">Ok</span>(config)
}</code></pre>

      <p>
        <code>anyhow::Result&lt;T&gt;</code> is an alias for
        <code>Result&lt;T, anyhow::Error&gt;</code>. <code>anyhow::Error</code> wraps
        any error type (anything implementing <code>std::error::Error</code>). You don't
        define error enums at all.
      </p>
      <p>
        <code>.context("...")</code> adds a human-readable message. When the error is
        displayed, you get a chain:
      </p>

      <pre><code><span class="cm">Error: failed to read config file

Caused by:
    No such file or directory (os error 2)</span></code></pre>

      <p>
        This is exactly what you want in an application: clear error messages with context,
        minimal boilerplate, and no need to define error types for every module.
      </p>

      <h2>The split</h2>

      <p>
        This is the standard Rust approach:
      </p>
      <ul>
        <li><strong>Libraries</strong> use <code>thiserror</code>. They define structured
          error types that callers can match on. The error type is part of the public API.</li>
        <li><strong>Applications</strong> (binaries) use <code>anyhow</code>. They pass
          errors up with context messages. Nobody matches on the error &mdash; it gets
          printed for the user.</li>
      </ul>

      <h2>When the line blurs</h2>

      <p>
        Sometimes the code inside a library doesn't need structured errors &mdash; it's
        private logic that wraps errors before returning them to callers. Using
        <code>anyhow</code> internally and converting to <code>thiserror</code> types at
        the public boundary works fine.
      </p>
      <p>
        Conversely, if you find yourself pattern-matching on <code>anyhow::Error</code>
        (downcasting to specific types), that's a sign you need structured errors. Switch
        to <code>thiserror</code>.
      </p>

      <h2>The <code>?</code> operator ties it together</h2>

      <p>
        Everything in this post works because <code>?</code> calls <code>From::from()</code>
        to convert errors (as covered in <a href="rust-patterns-from-into.html">#15</a>).
        <code>thiserror</code> generates the <code>From</code> impls with <code>#[from]</code>.
        <code>anyhow</code> provides a blanket <code>From&lt;E: Error&gt;</code> for
        <code>anyhow::Error</code>. Both approaches plug into the same conversion system.
      </p>

      <h2>Error downcasting and the <code>source()</code> chain</h2>

      <p>
        The <code>std::error::Error</code> trait has a <code>source()</code> method
        that returns the underlying cause of an error, if any. This creates a chain:
        your application error wraps a library error, which wraps an OS error.
        <code>thiserror</code> generates the <code>source()</code> implementation
        automatically when you use <code>#[source]</code> or <code>#[from]</code>.
      </p>
      <p>
        <code>anyhow</code> preserves this chain and prints it with
        <code>{:?}</code> or <code>.chain()</code>. You can also downcast an
        <code>anyhow::Error</code> to a specific type when you need to:
      </p>

      <pre><code><span class="kw">use</span> anyhow::<span class="ty">Result</span>;

<span class="kw">fn</span> <span class="fn">handle</span>(err: anyhow::<span class="ty">Error</span>) {
    <span class="kw">if let</span> <span class="ty">Some</span>(io_err) = err.<span class="fn">downcast_ref</span>::&lt;std::io::<span class="ty">Error</span>&gt;() {
        <span class="kw">match</span> io_err.<span class="fn">kind</span>() {
            std::io::<span class="ty">ErrorKind</span>::<span class="ty">NotFound</span> =&gt; {
                <span class="cm">// handle missing file</span>
            }
            _ =&gt; { <span class="cm">/* other IO errors */</span> }
        }
    }
}</code></pre>

      <p>
        If you find yourself downcasting frequently, that's a sign you should switch
        to <code>thiserror</code> with structured variants. Downcasting is a runtime
        type check — it works, but pattern matching on an enum is checked at compile
        time and can't silently miss a case.
      </p>

      <h2>What does this cost?</h2>

      <p>
        <code>thiserror</code> generates zero runtime overhead beyond what you'd
        write by hand — it's a proc macro that emits <code>Display</code> and
        <code>From</code> impls. The error enum is stack-allocated, sized to its
        largest variant. <code>anyhow::Error</code> heap-allocates: it stores the
        error behind a pointer with a vtable for downcasting. The allocation happens
        once per error. Since errors are the exceptional path, this cost is
        irrelevant in practice — you're about to unwind or log, not iterate in a
        tight loop. The real cost of poor error handling isn't runtime — it's lost
        diagnostic information when you erase types too aggressively or forget to
        add context.
      </p>

      <h2>When to use it</h2>

      <ul>
        <li><strong><code>thiserror</code></strong>: any crate published for others to
          use, any module where callers need to match on specific error cases</li>
        <li><strong><code>anyhow</code></strong>: binary applications, CLI tools, scripts,
          anything where errors get printed for a human rather than matched on by code</li>
        <li><strong>Manual enums</strong>: when you want full control and don't want the
          dependency &mdash; the pattern is the same, just more verbose</li>
      </ul>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-interior-mutability.html">#1: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#2: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><a href="rust-patterns-cow.html">#6: Cow &mdash; Borrow or Own</a></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#7: Lifetime Annotations</a></li>
          <li><a href="rust-patterns-static-clone.html">#8: &rsquo;static + Clone</a></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-newtype.html">#11: Newtype</a></li>
          <li><a href="rust-patterns-typestate.html">#12: Typestate</a></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><strong>#16: Error Handling</strong></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#19: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
