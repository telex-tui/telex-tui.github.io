<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #6: Cow - Telex</title>
  <meta name="description" content="Cow lets you borrow when you can and own when you must — the ideal pattern for functions that sometimes modify their input and sometimes don't.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #6: Cow &mdash; Borrow or Own</h1>
      <div class="post-meta">April 2026</div>
      <p class="series-nav">Post 6 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        Functions receive data and sometimes need to modify it, sometimes don't. A URL
        normalizer might lowercase a path that has uppercase letters but leave an
        already-lowercase path unchanged. A text processor might strip whitespace from
        strings that have it but pass clean strings through. In these cases, cloning the
        input "just in case" wastes memory &mdash; most of the time no modification is
        needed. But you can't return a reference if you sometimes need to return modified
        data. <code>Cow</code> (clone-on-write) handles both cases: it borrows the
        original when possible and only allocates a new copy when modification is actually
        required.
      </p>

      <h2>The motivation</h2>

      <p>
        You're writing a function that escapes special characters in a string. Most of the
        strings you'll see have nothing to escape and come back unchanged. Once in a while,
        one does, and you need to return a modified copy.
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">escape</span>(input: &amp;<span class="kw">str</span>) -&gt; <span class="ty">String</span> {
    <span class="kw">if</span> input.<span class="fn">contains</span>(<span class="str">'&amp;'</span>) {
        input.<span class="fn">replace</span>(<span class="str">'&amp;'</span>, <span class="str">"&amp;amp;"</span>)
    } <span class="kw">else</span> {
        input.<span class="fn">to_string</span>() <span class="cm">// allocates even though nothing changed</span>
    }
}</code></pre>

      <p>
        The <code>else</code> branch allocates a brand-new <code>String</code> just to hand
        back the same text. If you call this function on thousands of strings and most of
        them don't need escaping, you're paying for thousands of allocations you didn't need.
      </p>
      <p>
        You could return <code>&amp;str</code> instead, but then you can't return the
        modified string &mdash; it's a local <code>String</code> that gets dropped at the
        end of the function. You need a return type that can be either a reference or an
        owned value.
      </p>

      <h2>The pattern: <code>Cow&lt;'a, str&gt;</code></h2>

      <p>
        <code>Cow</code> stands for "clone on write." It's an enum with two variants:
      </p>

      <pre><code><span class="kw">enum</span> <span class="ty">Cow</span>&lt;<span class="kw">'a</span>, <span class="ty">B</span>: <span class="ty">ToOwned</span>&gt; {
    <span class="ty">Borrowed</span>(&amp;<span class="kw">'a</span> <span class="ty">B</span>),
    <span class="ty">Owned</span>(&lt;<span class="ty">B</span> <span class="kw">as</span> <span class="ty">ToOwned</span>&gt;::<span class="ty">Owned</span>),
}</code></pre>

      <p>
        For strings, that means <code>Cow::Borrowed(&amp;str)</code> or
        <code>Cow::Owned(String)</code>. Your function picks the right one:
      </p>

      <pre><code><span class="kw">use</span> std::borrow::<span class="ty">Cow</span>;

<span class="kw">fn</span> <span class="fn">escape</span>&lt;<span class="kw">'a</span>&gt;(input: &amp;<span class="kw">'a</span> <span class="kw">str</span>) -&gt; <span class="ty">Cow</span>&lt;<span class="kw">'a</span>, <span class="kw">str</span>&gt; {
    <span class="kw">if</span> input.<span class="fn">contains</span>(<span class="str">'&amp;'</span>) {
        <span class="ty">Cow</span>::<span class="ty">Owned</span>(input.<span class="fn">replace</span>(<span class="str">'&amp;'</span>, <span class="str">"&amp;amp;"</span>))
    } <span class="kw">else</span> {
        <span class="ty">Cow</span>::<span class="ty">Borrowed</span>(input)
    }
}</code></pre>

      <p>
        When nothing needs escaping, the function hands back the original reference
        without allocating. When something does, it returns the new <code>String</code>.
        Either way, callers treat the result the same &mdash;
        <code>Cow&lt;str&gt;</code> implements <code>Deref&lt;Target = str&gt;</code>,
        so you can use it anywhere you'd use a <code>&amp;str</code>.
      </p>

      <h2>Using <code>Cow</code> at call sites</h2>

      <pre><code><span class="kw">let</span> clean = <span class="str">"hello world"</span>;
<span class="kw">let</span> dirty = <span class="str">"Tom &amp; Jerry"</span>;

<span class="kw">let</span> a = <span class="fn">escape</span>(clean); <span class="cm">// Cow::Borrowed — no allocation</span>
<span class="kw">let</span> b = <span class="fn">escape</span>(dirty); <span class="cm">// Cow::Owned — allocated</span>

<span class="cm">// Both work as &amp;str:</span>
<span class="mac">println!</span>(<span class="str">"{} {}"</span>, a.<span class="fn">len</span>(), b.<span class="fn">len</span>());

<span class="cm">// If you need a String, .into_owned() gives you one:</span>
<span class="kw">let</span> s: <span class="ty">String</span> = a.<span class="fn">into_owned</span>(); <span class="cm">// clones only if borrowed</span></code></pre>

      <p>
        <code>.into_owned()</code> gives you a <code>String</code>. If the <code>Cow</code>
        was already <code>Owned</code>, it just unwraps and hands it over &mdash; no
        allocation. If it was <code>Borrowed</code>, it clones.
      </p>

      <h2>Beyond strings</h2>

      <p>
        <code>Cow</code> works with any type that implements <code>ToOwned</code>:
      </p>
      <ul>
        <li><code>Cow&lt;str&gt;</code> &mdash; <code>&amp;str</code> or <code>String</code></li>
        <li><code>Cow&lt;[u8]&gt;</code> &mdash; <code>&amp;[u8]</code> or <code>Vec&lt;u8&gt;</code></li>
        <li><code>Cow&lt;Path&gt;</code> &mdash; <code>&amp;Path</code> or <code>PathBuf</code></li>
        <li><code>Cow&lt;[T]&gt;</code> &mdash; <code>&amp;[T]</code> or <code>Vec&lt;T&gt;</code></li>
      </ul>
      <p>
        The pattern is the same everywhere: borrow when you can, own when you must.
      </p>

      <h2>Cow in high-performance parsers</h2>

      <p>
        This is how <code>serde_json</code> handles string values. Most JSON strings
        contain no escape sequences — they're plain UTF-8 that can be referenced
        directly from the input buffer. When a string does contain escapes like
        <code>\n</code> or <code>\u0041</code>, the parser has to decode them into a
        new <code>String</code>. Using <code>Cow&lt;'a, str&gt;</code> as the output
        type means: zero allocation for the common case, owned allocation only when
        escapes force it.
      </p>

      <pre><code><span class="kw">use</span> std::borrow::<span class="ty">Cow</span>;

<span class="kw">fn</span> <span class="fn">decode_json_string</span>&lt;<span class="kw">'a</span>&gt;(raw: &amp;<span class="kw">'a</span> <span class="kw">str</span>) -&gt; <span class="ty">Cow</span>&lt;<span class="kw">'a</span>, <span class="kw">str</span>&gt; {
    <span class="kw">if</span> !raw.<span class="fn">contains</span>(<span class="str">'\\'</span>) {
        <span class="cm">// No escapes — borrow directly from the input buffer</span>
        <span class="ty">Cow</span>::<span class="ty">Borrowed</span>(raw)
    } <span class="kw">else</span> {
        <span class="cm">// Has escapes — must allocate to hold the decoded output</span>
        <span class="kw">let</span> <span class="kw">mut</span> out = <span class="ty">String</span>::<span class="fn">with_capacity</span>(raw.<span class="fn">len</span>());
        <span class="kw">let</span> <span class="kw">mut</span> chars = raw.<span class="fn">chars</span>();
        <span class="kw">while let</span> <span class="ty">Some</span>(c) = chars.<span class="fn">next</span>() {
            <span class="kw">if</span> c == <span class="str">'\\'</span> {
                <span class="kw">match</span> chars.<span class="fn">next</span>() {
                    <span class="ty">Some</span>(<span class="str">'n'</span>) =&gt; out.<span class="fn">push</span>(<span class="str">'\n'</span>),
                    <span class="ty">Some</span>(<span class="str">'t'</span>) =&gt; out.<span class="fn">push</span>(<span class="str">'\t'</span>),
                    <span class="ty">Some</span>(other) =&gt; out.<span class="fn">push</span>(other),
                    <span class="ty">None</span> =&gt; {}
                }
            } <span class="kw">else</span> {
                out.<span class="fn">push</span>(c);
            }
        }
        <span class="ty">Cow</span>::<span class="ty">Owned</span>(out)
    }
}</code></pre>

      <p>
        In real-world JSON, the vast majority of string values have no escapes. A
        parser using <code>Cow</code> avoids allocating for those strings entirely —
        it just returns a slice into the original input bytes. This is the foundation
        of zero-copy deserialization: the parsed output borrows from the input buffer
        instead of copying into new allocations. Serde's
        <code>#[serde(borrow)]</code> attribute enables this at the derive level.
      </p>

      <h2>Mutating through <code>Cow</code></h2>

      <p>
        <code>Cow</code> has a <code>.to_mut()</code> method that gives you an
        <code>&amp;mut</code> reference to the data. If the <code>Cow</code> is
        currently <code>Borrowed</code>, calling <code>.to_mut()</code> clones the data
        into an <code>Owned</code> variant first &mdash; that's the "clone on write" part:
      </p>

      <pre><code><span class="kw">let</span> <span class="kw">mut</span> s: <span class="ty">Cow</span>&lt;<span class="kw">str</span>&gt; = <span class="ty">Cow</span>::<span class="ty">Borrowed</span>(<span class="str">"hello"</span>);

<span class="cm">// Triggers a clone because it's currently Borrowed</span>
s.<span class="fn">to_mut</span>().<span class="fn">push_str</span>(<span class="str">" world"</span>);
<span class="cm">// s is now Cow::Owned("hello world")</span></code></pre>

      <h2>What does this cost?</h2>

      <p>
        <code>Cow</code> is an enum — one discriminant byte (plus alignment padding)
        to distinguish <code>Borrowed</code> from <code>Owned</code>. For
        <code>Cow&lt;str&gt;</code>, the size is the same as a <code>String</code>
        (pointer + length + capacity) because the enum must accommodate the larger
        variant. The cost of the branch on the discriminant is negligible. The real
        value is in what you <em>don't</em> pay: no allocation in the
        <code>Borrowed</code> path. This is a zero-cost abstraction in the literal
        sense — the <code>Borrowed</code> variant compiles down to the same code as
        passing a plain <code>&amp;str</code>.
      </p>

      <h2>When to use it</h2>

      <p>
        <strong>Good uses:</strong>
      </p>
      <ul>
        <li>String processing where most inputs come back unchanged (escaping, normalisation)</li>
        <li>Config values with defaults &mdash; return the default as <code>Borrowed</code>,
          user overrides as <code>Owned</code></li>
        <li>Functions that only sometimes need to change their input</li>
        <li>APIs that accept both <code>&amp;str</code> and <code>String</code>
          without forcing callers to pick one</li>
      </ul>
      <p>
        <strong>When not to use it:</strong>
      </p>
      <ul>
        <li>If you always modify the input, just take and return <code>String</code></li>
        <li>If you never modify the input, just take <code>&amp;str</code></li>
        <li>If the extra allocations don't matter in your case, returning
          <code>String</code> is simpler to read</li>
      </ul>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-interior-mutability.html">#1: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#2: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><strong>#6: Cow &mdash; Borrow or Own</strong></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#7: Lifetime Annotations</a></li>
          <li><a href="rust-patterns-static-clone.html">#8: &rsquo;static + Clone</a></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-newtype.html">#11: Newtype</a></li>
          <li><a href="rust-patterns-typestate.html">#12: Typestate</a></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#16: Error Handling</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#19: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
