<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #6: Cow - Telex</title>
  <meta name="description" content="Cow lets you borrow when you can and own when you must — the ideal pattern for functions that sometimes modify their input and sometimes don't.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #6: Cow &mdash; Borrow or Own</h1>
      <div class="post-meta">April 2026</div>
      <p class="series-nav">Post 6 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        Should your function take <code>&amp;str</code> or <code>String</code>? If it takes
        <code>&amp;str</code>, callers who have a <code>String</code> can just pass a reference.
        But if the function sometimes needs to modify the string, it has to allocate a new
        <code>String</code> every time &mdash; even when it returns the input unchanged.
        <code>Cow</code> solves this.
      </p>

      <h2>The motivation</h2>

      <p>
        You're writing a function that escapes special characters in a string. Most of the
        strings you'll see have nothing to escape and come back unchanged. Once in a while,
        one does, and you need to return a modified copy.
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">escape</span>(input: &amp;<span class="kw">str</span>) -&gt; <span class="ty">String</span> {
    <span class="kw">if</span> input.<span class="fn">contains</span>(<span class="str">'&amp;'</span>) {
        input.<span class="fn">replace</span>(<span class="str">'&amp;'</span>, <span class="str">"&amp;amp;"</span>)
    } <span class="kw">else</span> {
        input.<span class="fn">to_string</span>() <span class="cm">// allocates even though nothing changed</span>
    }
}</code></pre>

      <p>
        The <code>else</code> branch allocates a brand-new <code>String</code> just to hand
        back the same text. If you call this function on thousands of strings and most of
        them don't need escaping, you're paying for thousands of allocations you didn't need.
      </p>
      <p>
        You could return <code>&amp;str</code> instead, but then you can't return the
        modified string &mdash; it's a local <code>String</code> that gets dropped at the
        end of the function. You need a return type that can be either a reference or an
        owned value.
      </p>

      <h2>The pattern: <code>Cow&lt;'a, str&gt;</code></h2>

      <p>
        <code>Cow</code> stands for "clone on write." It's an enum with two variants:
      </p>

      <pre><code><span class="kw">enum</span> <span class="ty">Cow</span>&lt;<span class="kw">'a</span>, <span class="ty">B</span>: <span class="ty">ToOwned</span>&gt; {
    <span class="ty">Borrowed</span>(&amp;<span class="kw">'a</span> <span class="ty">B</span>),
    <span class="ty">Owned</span>(&lt;<span class="ty">B</span> <span class="kw">as</span> <span class="ty">ToOwned</span>&gt;::<span class="ty">Owned</span>),
}</code></pre>

      <p>
        For strings, that means <code>Cow::Borrowed(&amp;str)</code> or
        <code>Cow::Owned(String)</code>. Your function picks the right one:
      </p>

      <pre><code><span class="kw">use</span> std::borrow::<span class="ty">Cow</span>;

<span class="kw">fn</span> <span class="fn">escape</span>&lt;<span class="kw">'a</span>&gt;(input: &amp;<span class="kw">'a</span> <span class="kw">str</span>) -&gt; <span class="ty">Cow</span>&lt;<span class="kw">'a</span>, <span class="kw">str</span>&gt; {
    <span class="kw">if</span> input.<span class="fn">contains</span>(<span class="str">'&amp;'</span>) {
        <span class="ty">Cow</span>::<span class="ty">Owned</span>(input.<span class="fn">replace</span>(<span class="str">'&amp;'</span>, <span class="str">"&amp;amp;"</span>))
    } <span class="kw">else</span> {
        <span class="ty">Cow</span>::<span class="ty">Borrowed</span>(input)
    }
}</code></pre>

      <p>
        When nothing needs escaping, the function hands back the original reference
        without allocating. When something does, it returns the new <code>String</code>.
        Either way, callers treat the result the same &mdash;
        <code>Cow&lt;str&gt;</code> implements <code>Deref&lt;Target = str&gt;</code>,
        so you can use it anywhere you'd use a <code>&amp;str</code>.
      </p>

      <h2>Using <code>Cow</code> at call sites</h2>

      <pre><code><span class="kw">let</span> clean = <span class="str">"hello world"</span>;
<span class="kw">let</span> dirty = <span class="str">"Tom &amp; Jerry"</span>;

<span class="kw">let</span> a = <span class="fn">escape</span>(clean); <span class="cm">// Cow::Borrowed — no allocation</span>
<span class="kw">let</span> b = <span class="fn">escape</span>(dirty); <span class="cm">// Cow::Owned — allocated</span>

<span class="cm">// Both work as &amp;str:</span>
<span class="mac">println!</span>(<span class="str">"{} {}"</span>, a.<span class="fn">len</span>(), b.<span class="fn">len</span>());

<span class="cm">// If you need a String, .into_owned() gives you one:</span>
<span class="kw">let</span> s: <span class="ty">String</span> = a.<span class="fn">into_owned</span>(); <span class="cm">// clones only if borrowed</span></code></pre>

      <p>
        <code>.into_owned()</code> gives you a <code>String</code>. If the <code>Cow</code>
        was already <code>Owned</code>, it just unwraps and hands it over &mdash; no
        allocation. If it was <code>Borrowed</code>, it clones.
      </p>

      <h2>Beyond strings</h2>

      <p>
        <code>Cow</code> works with any type that implements <code>ToOwned</code>:
      </p>
      <ul>
        <li><code>Cow&lt;str&gt;</code> &mdash; <code>&amp;str</code> or <code>String</code></li>
        <li><code>Cow&lt;[u8]&gt;</code> &mdash; <code>&amp;[u8]</code> or <code>Vec&lt;u8&gt;</code></li>
        <li><code>Cow&lt;Path&gt;</code> &mdash; <code>&amp;Path</code> or <code>PathBuf</code></li>
        <li><code>Cow&lt;[T]&gt;</code> &mdash; <code>&amp;[T]</code> or <code>Vec&lt;T&gt;</code></li>
      </ul>
      <p>
        The pattern is the same everywhere: borrow when you can, own when you must.
      </p>

      <h2>Mutating through <code>Cow</code></h2>

      <p>
        <code>Cow</code> has a <code>.to_mut()</code> method that gives you an
        <code>&amp;mut</code> reference to the data. If the <code>Cow</code> is
        currently <code>Borrowed</code>, calling <code>.to_mut()</code> clones the data
        into an <code>Owned</code> variant first &mdash; that's the "clone on write" part:
      </p>

      <pre><code><span class="kw">let</span> <span class="kw">mut</span> s: <span class="ty">Cow</span>&lt;<span class="kw">str</span>&gt; = <span class="ty">Cow</span>::<span class="ty">Borrowed</span>(<span class="str">"hello"</span>);

<span class="cm">// Triggers a clone because it's currently Borrowed</span>
s.<span class="fn">to_mut</span>().<span class="fn">push_str</span>(<span class="str">" world"</span>);
<span class="cm">// s is now Cow::Owned("hello world")</span></code></pre>

      <h2>When to use it</h2>

      <p>
        <strong>Good uses:</strong>
      </p>
      <ul>
        <li>String processing where most inputs come back unchanged (escaping, normalisation)</li>
        <li>Config values with defaults &mdash; return the default as <code>Borrowed</code>,
          user overrides as <code>Owned</code></li>
        <li>Functions that only sometimes need to change their input</li>
        <li>APIs that accept both <code>&amp;str</code> and <code>String</code>
          without forcing callers to pick one</li>
      </ul>
      <p>
        <strong>When not to use it:</strong>
      </p>
      <ul>
        <li>If you always modify the input, just take and return <code>String</code></li>
        <li>If you never modify the input, just take <code>&amp;str</code></li>
        <li>If the extra allocations don't matter in your case, returning
          <code>String</code> is simpler to read</li>
      </ul>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-interior-mutability.html">#1: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#2: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><strong>#6: Cow &mdash; Borrow or Own</strong></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#7: Lifetime Annotations</a></li>
          <li><a href="rust-patterns-static-clone.html">#8: &rsquo;static + Clone</a></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-newtype.html">#11: Newtype</a></li>
          <li><a href="rust-patterns-typestate.html">#12: Typestate</a></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#16: Error Handling</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#19: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
