<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #16: Storing and Returning Closures - Telex</title>
  <meta name="description" content="Closures have anonymous types you can't name. To store them in structs or return them from functions, use Box dyn Fn or impl Fn â€” here's when to use which.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #16: Storing and Returning Closures</h1>
      <div class="post-meta">May 2026</div>
      <p class="series-nav">Post 16 of 22 in <a href="#series-index">Rust Patterns That Matter</a>. Companion series: <a href="chat-server-hello-tcp.html">Building a Chat Server in Rust</a>.</p>
      <p class="series-nav">Previous: <a href="rust-patterns-closure-traits.html">#15: Fn, FnMut, FnOnce</a> | Next: <a href="rust-patterns-builder.html">#17: Builder Pattern</a></p>

      <p>
        You want a struct with a callback field. What type do you give it? You want a
        function that returns a closure. What return type do you write? The answer touches
        one of Rust's most distinctive features: every closure has a unique, anonymous type
        that you can't name.
      </p>

      <h2>The motivation</h2>

      <pre><code><span class="kw">struct</span> <span class="ty">Button</span> {
    label: <span class="ty">String</span>,
    on_click: ???, <span class="cm">// what type goes here?</span>
}</code></pre>

      <p>
        You try <code>fn()</code>, but that only works for function pointers, not closures
        that capture variables. You try <code>Fn()</code>:
      </p>

      <pre><code><span class="cm">error[E0277]: the size for values of type `dyn Fn()`
              cannot be known at compile time</span></code></pre>

      <p>
        <code>dyn Fn()</code> is a trait object - it has no fixed size. You can't
        put an unsized type directly in a struct field.
      </p>

      <h2>Why closure types are anonymous</h2>

      <p>
        Each closure the compiler generates is a unique struct. It captures the
        variables it needs and implements the appropriate <code>Fn</code> trait. The struct's
        name is generated by the compiler and never exposed to you.
      </p>

      <pre><code><span class="kw">let</span> a = |x: <span class="ty">i32</span>| x + <span class="num">1</span>;
<span class="kw">let</span> b = |x: <span class="ty">i32</span>| x + <span class="num">2</span>;
<span class="cm">// a and b have DIFFERENT types, even though both are Fn(i32) -> i32</span></code></pre>

      <p>
        This is intentional. Unique types let the compiler monomorphise: each closure's call
        is inlined directly, with no dynamic dispatch overhead. But it means you can't write
        a struct field like <code>callback: the_type_of_my_closure</code> because that type
        has no name.
      </p>

      <h2>Pattern 1: <code>Box&lt;dyn Fn()&gt;</code></h2>

      <p>
        Heap-allocate the closure behind a trait object. The struct stores a fixed-size
        pointer:
      </p>

      <pre><code><span class="kw">struct</span> <span class="ty">Button</span> {
    label: <span class="ty">String</span>,
    on_click: <span class="ty">Box</span>&lt;<span class="kw">dyn</span> <span class="ty">Fn</span>()&gt;,
}

<span class="kw">impl</span> <span class="ty">Button</span> {
    <span class="kw">fn</span> <span class="fn">new</span>(label: <span class="kw">impl</span> <span class="ty">Into</span>&lt;<span class="ty">String</span>&gt;, on_click: <span class="kw">impl</span> <span class="ty">Fn</span>() + <span class="kw">'static</span>) -&gt; <span class="kw">Self</span> {
        <span class="ty">Button</span> {
            label: label.<span class="fn">into</span>(),
            on_click: <span class="ty">Box</span>::<span class="fn">new</span>(on_click),
        }
    }

    <span class="kw">fn</span> <span class="fn">click</span>(&amp;<span class="kw">self</span>) {
        (<span class="kw">self</span>.on_click)();
    }
}

<span class="kw">fn</span> <span class="fn">main</span>() {
    <span class="kw">let</span> btn = <span class="ty">Button</span>::<span class="fn">new</span>(<span class="str">"Submit"</span>, || <span class="mac">println!</span>(<span class="str">"clicked!"</span>));
    btn.<span class="fn">click</span>();
}</code></pre>

      <p>
        <code>Box&lt;dyn Fn()&gt;</code> is the pragmatic default for stored closures.
        One heap allocation to store the closure, and a vtable pointer for dynamic dispatch.
        The overhead is negligible for event handlers and callbacks.
      </p>

      <h2>Pattern 2: Generics</h2>

      <p>
        If you want to avoid the heap allocation, make the struct generic over the closure
        type:
      </p>

      <pre><code><span class="kw">struct</span> <span class="ty">Button</span>&lt;<span class="ty">F</span>: <span class="ty">Fn</span>()&gt; {
    label: <span class="ty">String</span>,
    on_click: <span class="ty">F</span>,
}</code></pre>

      <p>
        This is monomorphised: no heap allocation, no dynamic dispatch. The closure is
        stored inline. But the struct's type now includes the closure's anonymous type,
        which means:
      </p>
      <ul>
        <li>You can't store different <code>Button</code>s in the same <code>Vec</code>
          (they have different types)</li>
        <li>The type parameter propagates everywhere the <code>Button</code> is used</li>
      </ul>
      <p>
        Generics work well when a struct has exactly one callback and you don't need to
        store heterogeneous instances. For anything more flexible, use <code>Box&lt;dyn Fn&gt;</code>.
      </p>

      <h2>Returning closures</h2>

      <p>
        To return a closure from a function, use <code>impl Fn</code> in the return type:
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">make_adder</span>(n: <span class="ty">i32</span>) -&gt; <span class="kw">impl</span> <span class="ty">Fn</span>(<span class="ty">i32</span>) -&gt; <span class="ty">i32</span> {
    <span class="kw">move</span> |x| x + n
}

<span class="kw">let</span> add_five = <span class="fn">make_adder</span>(<span class="num">5</span>);
<span class="mac">println!</span>(<span class="str">"{}"</span>, <span class="fn">add_five</span>(<span class="num">3</span>)); <span class="cm">// 8</span></code></pre>

      <p>
        <code>impl Fn(i32) -&gt; i32</code> means "I'm returning some concrete type that
        implements this trait, but I'm not telling you which one." The compiler knows the
        concrete type and monomorphises the caller. No heap allocation.
      </p>
      <p>
        The limitation: all return paths must return the same concrete type. You can't
        conditionally return different closures:
      </p>

      <pre><code><span class="cm">// ERROR: `if` and `else` have incompatible types</span>
<span class="kw">fn</span> <span class="fn">make_op</span>(add: <span class="ty">bool</span>) -&gt; <span class="kw">impl</span> <span class="ty">Fn</span>(<span class="ty">i32</span>) -&gt; <span class="ty">i32</span> {
    <span class="kw">if</span> add {
        |x| x + <span class="num">1</span>
    } <span class="kw">else</span> {
        |x| x * <span class="num">2</span> <span class="cm">// different anonymous type!</span>
    }
}</code></pre>

      <h2>Boxing for conditional returns</h2>

      <p>
        When you need to return different closures from different branches, box them:
      </p>

      <pre><code><span class="kw">fn</span> <span class="fn">make_op</span>(add: <span class="ty">bool</span>) -&gt; <span class="ty">Box</span>&lt;<span class="kw">dyn</span> <span class="ty">Fn</span>(<span class="ty">i32</span>) -&gt; <span class="ty">i32</span>&gt; {
    <span class="kw">if</span> add {
        <span class="ty">Box</span>::<span class="fn">new</span>(|x| x + <span class="num">1</span>)
    } <span class="kw">else</span> {
        <span class="ty">Box</span>::<span class="fn">new</span>(|x| x * <span class="num">2</span>)
    }
}</code></pre>

      <p>
        Both branches return <code>Box&lt;dyn Fn(i32) -&gt; i32&gt;</code> - a single
        concrete type (the box) wrapping different trait objects. This compiles.
      </p>

      <h2>Telex's approach: <code>Rc&lt;dyn Fn()&gt;</code></h2>

      <p>
        Telex stores callbacks as <code>Rc&lt;dyn Fn()&gt;</code> instead of
        <code>Box&lt;dyn Fn()&gt;</code>. The reason: a single callback might be cloned
        into multiple event handlers (a button's click handler registered with both a
        keyboard shortcut and a mouse target). <code>Rc</code> allows sharing the same
        closure without heap-allocating separate copies. See
        <a href="designing-a-tui-framework-in-rust.html">Designing a TUI Framework -
        Part 1</a> for details.
      </p>

      <h2>When to use which</h2>

      <ul>
        <li><strong><code>Box&lt;dyn Fn&gt;</code></strong> - struct fields,
          heterogeneous collections, any time you need to store a closure and the type
          can vary</li>
        <li><strong>Generics (<code>F: Fn</code>)</strong> - hot paths where you
          want inlining, or when the struct has a single closure that's known at construction
          time</li>
        <li><strong><code>impl Fn</code></strong> - return types when there's one
          concrete closure being returned</li>
        <li><strong><code>Rc&lt;dyn Fn&gt;</code></strong> - when the same closure
          needs to be shared (cloned) across multiple owners</li>
        <li><strong><code>fn()</code> pointer</strong> - when the closure captures
          nothing (function pointers are simpler and have no allocation)</li>
      </ul>

      <p>
        <em>See it in practice:</em> <a href="chat-server-commands.html">Building a Chat Server #4: Commands and Plugins</a> uses this pattern for the filter registry.
      </p>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-newtype.html">#1: Newtype</a></li>
          <li><a href="rust-patterns-from-into.html">#2: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#3: Error Handling</a></li>
          <li><a href="rust-patterns-interior-mutability.html">#4: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#5: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#6: The Combo - Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#7: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#8: Index-Based Design</a></li>
          <li><a href="rust-patterns-drop-raii.html">#9: Drop and RAII</a></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#10: Lifetime Annotations</a></li>
          <li><a href="rust-patterns-cow.html">#11: Cow - Borrow or Own</a></li>
          <li><a href="rust-patterns-iterators.html">#12: Custom Iterators</a></li>
          <li><a href="rust-patterns-static-clone.html">#13: 'static + Clone</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-closure-traits.html">#15: Fn, FnMut, FnOnce</a></li>
          <li><strong>#16: Storing and Returning Closures</strong></li>
          <li><a href="rust-patterns-builder.html">#17: Builder Pattern</a></li>
          <li><a href="rust-patterns-typestate.html">#18: Typestate</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#19: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#20: Channels - Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#21: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#22: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT - Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
