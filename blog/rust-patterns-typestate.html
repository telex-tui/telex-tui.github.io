<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #12: Typestate - Telex</title>
  <meta name="description" content="Encode your state machine's states as types and transitions as consuming methods. Invalid states become compile errors, not runtime bugs.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #12: Typestate</h1>
      <div class="post-meta">June 2026</div>
      <p class="series-nav">Post 12 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        Say you have a connection that moves through states: disconnected, connecting,
        connected. You should only be able to send data when connected. The straightforward
        approach is to check the state at runtime and panic or return an error if the caller
        does something wrong. The typestate pattern turns those mistakes into compile errors
        instead.
      </p>

      <h2>The motivation</h2>

      <pre><code><span class="kw">enum</span> <span class="ty">State</span> { <span class="ty">Disconnected</span>, <span class="ty">Connecting</span>, <span class="ty">Connected</span> }

<span class="kw">struct</span> <span class="ty">Connection</span> {
    state: <span class="ty">State</span>,
}

<span class="kw">impl</span> <span class="ty">Connection</span> {
    <span class="kw">fn</span> <span class="fn">send</span>(&amp;<span class="kw">self</span>, data: &amp;[<span class="ty">u8</span>]) -&gt; <span class="ty">Result</span>&lt;(), <span class="ty">Error</span>&gt; {
        <span class="kw">match</span> <span class="kw">self</span>.state {
            <span class="ty">State</span>::<span class="ty">Connected</span> =&gt; { <span class="cm">/* actually send */</span> <span class="ty">Ok</span>(()) }
            _ =&gt; <span class="ty">Err</span>(<span class="ty">Error</span>::<span class="fn">new</span>(<span class="str">"not connected"</span>)),
        }
    }
}</code></pre>

      <p>
        The problem: every method that cares about the current state needs a runtime check.
        Miss one and you have a bug. The type system can't help here &mdash; the compiler
        sees one <code>Connection</code> type no matter what state it's in.
      </p>

      <h2>The pattern: states as types</h2>

      <p>
        Make each state its own zero-sized type. Make <code>Connection</code> generic over
        the state. Each transition method takes ownership of the current connection and
        returns a new one in the next state:
      </p>

      <pre><code><span class="cm">// State markers — zero-sized, exist only in the type system</span>
<span class="kw">struct</span> <span class="ty">Disconnected</span>;
<span class="kw">struct</span> <span class="ty">Connecting</span>;
<span class="kw">struct</span> <span class="ty">Connected</span>;

<span class="kw">struct</span> <span class="ty">Connection</span>&lt;<span class="ty">S</span>&gt; {
    addr: <span class="ty">String</span>,
    _state: std::marker::<span class="ty">PhantomData</span>&lt;<span class="ty">S</span>&gt;,
}

<span class="kw">impl</span> <span class="ty">Connection</span>&lt;<span class="ty">Disconnected</span>&gt; {
    <span class="kw">fn</span> <span class="fn">new</span>(addr: <span class="ty">String</span>) -&gt; <span class="kw">Self</span> {
        <span class="ty">Connection</span> { addr, _state: std::marker::<span class="ty">PhantomData</span> }
    }

    <span class="kw">fn</span> <span class="fn">connect</span>(<span class="kw">self</span>) -&gt; <span class="ty">Connection</span>&lt;<span class="ty">Connecting</span>&gt; {
        <span class="mac">println!</span>(<span class="str">"connecting to {}..."</span>, <span class="kw">self</span>.addr);
        <span class="ty">Connection</span> { addr: <span class="kw">self</span>.addr, _state: std::marker::<span class="ty">PhantomData</span> }
    }
}

<span class="kw">impl</span> <span class="ty">Connection</span>&lt;<span class="ty">Connecting</span>&gt; {
    <span class="kw">fn</span> <span class="fn">on_connected</span>(<span class="kw">self</span>) -&gt; <span class="ty">Connection</span>&lt;<span class="ty">Connected</span>&gt; {
        <span class="mac">println!</span>(<span class="str">"connected!"</span>);
        <span class="ty">Connection</span> { addr: <span class="kw">self</span>.addr, _state: std::marker::<span class="ty">PhantomData</span> }
    }
}

<span class="kw">impl</span> <span class="ty">Connection</span>&lt;<span class="ty">Connected</span>&gt; {
    <span class="kw">fn</span> <span class="fn">send</span>(&amp;<span class="kw">self</span>, data: &amp;[<span class="ty">u8</span>]) {
        <span class="mac">println!</span>(<span class="str">"sending {} bytes"</span>, data.<span class="fn">len</span>());
    }

    <span class="kw">fn</span> <span class="fn">disconnect</span>(<span class="kw">self</span>) -&gt; <span class="ty">Connection</span>&lt;<span class="ty">Disconnected</span>&gt; {
        <span class="mac">println!</span>(<span class="str">"disconnected"</span>);
        <span class="ty">Connection</span> { addr: <span class="kw">self</span>.addr, _state: std::marker::<span class="ty">PhantomData</span> }
    }
}</code></pre>

      <p>
        The <code>send</code> method only exists when the connection is in the
        <code>Connected</code> state. If you try to call it on a disconnected connection, you
        don't get a runtime error &mdash; the code won't compile at all:
      </p>

      <pre><code><span class="kw">let</span> conn = <span class="ty">Connection</span>::<span class="fn">new</span>(<span class="str">"127.0.0.1"</span>.<span class="fn">into</span>());

<span class="cm">// conn.send(b"hello"); // ERROR: no method named `send` found</span>
<span class="cm">//                      //        for `Connection&lt;Disconnected&gt;`</span>

<span class="kw">let</span> conn = conn.<span class="fn">connect</span>();     <span class="cm">// Connection&lt;Connecting&gt;</span>
<span class="kw">let</span> conn = conn.<span class="fn">on_connected</span>(); <span class="cm">// Connection&lt;Connected&gt;</span>

conn.<span class="fn">send</span>(b<span class="str">"hello"</span>);            <span class="cm">// OK — we're connected</span>

<span class="kw">let</span> conn = conn.<span class="fn">disconnect</span>();   <span class="cm">// Connection&lt;Disconnected&gt;</span>
<span class="cm">// conn.send(b"hello");         // ERROR again — disconnected</span></code></pre>

      <h2>Why transition methods consume <code>self</code></h2>

      <p>
        Each transition takes <code>self</code> by value, not by reference. That means the
        old connection is moved and can't be used anymore. After you call
        <code>.connect()</code>, the <code>Connection&lt;Disconnected&gt;</code> is gone.
        You can't accidentally keep using a connection in the wrong state.
      </p>

      <h2>Resource cleanup with <code>Drop</code></h2>

      <p>
        Because each state is a separate type, you can implement <code>Drop</code>
        on intermediate states to prevent resource leaks. If a connection is dropped
        while still in the <code>Connecting</code> state — perhaps because an error
        caused early return — the <code>Drop</code> impl can cancel the pending
        connection:
      </p>

      <pre><code><span class="kw">impl</span> <span class="ty">Drop</span> <span class="kw">for</span> <span class="ty">Connection</span>&lt;<span class="ty">Connecting</span>&gt; {
    <span class="kw">fn</span> <span class="fn">drop</span>(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
        <span class="mac">eprintln!</span>(<span class="str">"connection to {} dropped while still connecting — aborting"</span>,
                  <span class="kw">self</span>.addr);
        <span class="cm">// cancel the pending connection, close the socket, etc.</span>
    }
}

<span class="kw">impl</span> <span class="ty">Drop</span> <span class="kw">for</span> <span class="ty">Connection</span>&lt;<span class="ty">Connected</span>&gt; {
    <span class="kw">fn</span> <span class="fn">drop</span>(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
        <span class="mac">eprintln!</span>(<span class="str">"connection to {} dropped while connected — sending FIN"</span>,
                  <span class="kw">self</span>.addr);
        <span class="cm">// graceful shutdown</span>
    }
}</code></pre>

      <p>
        With a runtime enum, you'd need a single <code>Drop</code> impl that
        matches on the current state — and forgetting a variant means a silent
        resource leak. With typestate, the compiler enforces that every state with
        cleanup needs gets its own <code>Drop</code>. If you add a new state and
        forget to implement <code>Drop</code> for it, the default (no-op drop) is
        explicit rather than an oversight hidden inside a match arm.
      </p>

      <h2>Zero-sized types</h2>

      <p>
        <code>struct Disconnected;</code> has no fields and takes up zero bytes. The
        <code>PhantomData&lt;S&gt;</code> field also takes up zero bytes. The state only
        exists while the compiler is checking your code &mdash; it's completely gone at
        runtime. <code>Connection&lt;Disconnected&gt;</code> and
        <code>Connection&lt;Connected&gt;</code> look identical in memory: just the
        <code>addr</code> field.
      </p>

      <h2>Tradeoffs</h2>

      <ul>
        <li><strong>More types, more impl blocks.</strong> Each state is its own type, so
          three states means three separate impl blocks. If some methods are the same across
          states, you need another <code>impl Connection&lt;S&gt;</code> block just for those.</li>
        <li><strong>You can't mix states in one collection.</strong>
          <code>Connection&lt;Disconnected&gt;</code> and <code>Connection&lt;Connected&gt;</code>
          are different types, so you can't put them in the same <code>Vec</code> or
          <code>HashMap</code> unless you erase the state (which defeats the point).</li>
        <li><strong>Doesn't work when state depends on runtime data.</strong> If the next state
          comes from user input, a config file, or an external event, you need an enum. The
          typestate pattern only works when the compiler can see which transition happens.</li>
      </ul>

      <h2>What does this cost?</h2>

      <p>
        Nothing at runtime. The state marker types are zero-sized —
        <code>PhantomData</code> compiles away entirely. The type parameter exists
        only during compilation; the generated machine code for
        <code>Connection&lt;Disconnected&gt;</code> and
        <code>Connection&lt;Connected&gt;</code> is identical in layout. Transition
        methods that move <code>self</code> compile to a no-op move of the data
        fields. The entire state machine is enforced purely by the type checker,
        with zero runtime overhead. Without typestate, you'd either check states at
        runtime (branching on an enum discriminant in every method) or use unsafe
        to assert states by convention.
      </p>

      <h2>When to use it</h2>

      <ul>
        <li>Protocol state machines (TCP connection, HTTP request/response lifecycle)</li>
        <li>Builder patterns with required steps
          (<a href="rust-patterns-builder.html">#13</a>)</li>
        <li>"Must do X before Y" constraints (open a file before reading, authenticate
          before querying)</li>
        <li>Any situation where which methods are valid depends on the current state and the
          transitions are known at compile time</li>
      </ul>
      <p>
        When not to: when the state comes from runtime data, when you have many states and
        the per-state method lists get unwieldy, or when you need to store connections in
        mixed states. Use an enum with runtime checks in those cases.
      </p>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-interior-mutability.html">#1: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#2: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><a href="rust-patterns-cow.html">#6: Cow &mdash; Borrow or Own</a></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#7: Lifetime Annotations</a></li>
          <li><a href="rust-patterns-static-clone.html">#8: &rsquo;static + Clone</a></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-newtype.html">#11: Newtype</a></li>
          <li><strong>#12: Typestate</strong></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#16: Error Handling</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#19: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
