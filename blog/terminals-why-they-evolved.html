<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Terminals: Why They Evolved the Way They Did - Telex</title>
  <meta name="description" content="A needs-first history of terminal devices in Unix: from physical teletypes to PTYs, signals, SSH, and multiplexers. Each concept motivated by the problem it solved.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Terminals: Why They Evolved the Way They Did</h1>
      <div class="post-meta">February 2026</div>

      <p>
        Most explanations of terminal devices in Unix start with the abstractions &mdash; TTYs,
        PTYs, line disciplines, session leaders &mdash; and expect you to appreciate why they
        exist. This post takes the opposite approach. Each concept is introduced by the problem
        that created it: there was a need for X, so Y was built, and we still have it today in
        the form of Z.
      </p>

      <h2>The wire</h2>

      <p>
        In the beginning, a terminal was a physical device connected to a computer by a serial
        cable. A Teletype (the original "TTY") had a keyboard and a printer. You typed a
        character, it traveled down the wire as a voltage pattern, the computer received it,
        processed it, and sent characters back down the same wire to be printed on paper.
      </p>
      <p>
        The kernel's job was simple: read bytes from a serial port, hand them to a program, take
        the program's output bytes, and write them back to the port. The device file
        <code>/dev/ttyS0</code> represented that physical wire. Programs didn't know or care what
        was on the other end &mdash; they read from and wrote to a file descriptor, and the
        kernel handled the hardware.
      </p>
      <p>
        This model &mdash; program talks to a character device, kernel mediates &mdash; is the
        foundation everything else is built on. Every complication that follows comes from
        trying to preserve this model after the hardware went away.
      </p>

      <h2>The hardware disappears: pseudoterminals</h2>

      <p>
        By the 1980s, terminals were moving from physical devices to software windows. Instead of
        a Teletype connected by a serial cable, you had a window on a graphical display. But
        programs like <code>bash</code> were written to talk to a character device &mdash; a TTY.
        A graphical window is just pixels managed by a GUI application. It's not a serial port.
        It has no device file.
      </p>
      <p>
        <strong>The need:</strong> a way to make software believe it's talking to hardware, while
        actually routing that data to a window on screen.
      </p>
      <p>
        <strong>The solution:</strong> the pseudoterminal, or PTY. It is created as a pair of
        file descriptors &mdash; two ends of a virtual wire.
      </p>
      <ul>
        <li>The <strong>slave</strong> side (<code>/dev/pts/0</code>, <code>/dev/pts/1</code>,
          etc.) behaves exactly like a physical TTY. The shell attaches to this side. As far as
          <code>bash</code> is concerned, it's talking to a serial port.</li>
        <li>The <strong>master</strong> side is held by the terminal emulator &mdash; the
          application drawing the window (Alacritty, GNOME Terminal, iTerm2, or anything
          else).</li>
      </ul>
      <p>
        When you type a character in your terminal window, the emulator writes it to the master.
        The kernel passes it through to the slave, where the shell reads it. When the shell
        produces output, it writes to the slave, the kernel passes it to the master, and the
        emulator draws the characters in its window.
      </p>
      <pre>
 You type 'l' 's' '\n'
        │
        ▼
 Terminal Emulator (Alacritty)
        │
        ▼
   PTY Master ──── kernel ──── PTY Slave (/dev/pts/1)
                                   │
                                   ▼
                                 bash
                                   │
                                   ▼
                          "file1.txt  file2.txt\n"
                                   │
                            (back through the PTY)
                                   │
                                   ▼
                          drawn in your window</pre>
      <p>
        The entire abstraction exists to trick programs that expect a hardware wire into working
        with a software window. The slave is the fake wire. The master is what's really there.
      </p>

      <h2>Resizable windows: SIGWINCH</h2>

      <p>
        On a physical Teletype, the "screen" size was fixed by the width of the paper or the
        dimensions of the CRT. When the terminal became a window, that changed. You could drag
        a corner and make it any size you wanted.
      </p>
      <p>
        <strong>The need:</strong> a way to tell a running program that the dimensions of its
        display just changed, so it can redraw itself.
      </p>
      <p>
        <strong>The solution:</strong> SIGWINCH &mdash; Signal Window Change. The process works
        like this:
      </p>
      <ol>
        <li>You resize the terminal window by dragging its edge.</li>
        <li>The terminal emulator (holding the master) tells the kernel: "The new dimensions are
          X columns and Y rows."</li>
        <li>The kernel updates the size stored for that PTY and sends a SIGWINCH signal to the
          process on the slave side.</li>
        <li>The process (say, <code>vim</code> or <code>htop</code>) receives the signal, queries
          the new dimensions via an <code>ioctl</code> call, and recalculates its layout.</li>
      </ol>
      <p>
        This is why full-screen terminal programs redraw correctly when you resize the window.
        Without SIGWINCH, they'd have no idea the canvas had changed. The signal is the only
        mechanism &mdash; there's no "poll the window size" API. You either handle SIGWINCH or
        you don't know.
      </p>

      <h2>Stuck programs: the line discipline</h2>

      <p>
        If you run a program that gets stuck in an infinite loop and hit Ctrl+C, the program
        stops. But think about what that means &mdash; the program is too busy looping to read
        its input. It will never see the Ctrl+C keystroke in its input buffer. So how does the
        stop command reach it?
      </p>
      <p>
        <strong>The need:</strong> out-of-band communication &mdash; a way to manage a process
        that isn't reading its standard input.
      </p>
      <p>
        <strong>The solution:</strong> the line discipline, a kernel layer that sits between the
        master and slave sides of the PTY and watches every byte that flows through.
      </p>
      <ol>
        <li>The terminal emulator sends the byte <code>0x03</code> (the code for Ctrl+C) to the
          master.</li>
        <li>The line discipline on the slave side sees this byte.</li>
        <li>Instead of passing <code>0x03</code> to the application's input buffer, the kernel
          converts it into a SIGINT signal and delivers it directly to the process group.</li>
      </ol>
      <p>
        The signal bypasses the input queue entirely. The program doesn't need to read it. The
        kernel intercepts the byte and converts it into an asynchronous signal &mdash; that's why
        Ctrl+C works even when a program is completely unresponsive.
      </p>
      <p>
        This is also why "raw mode" exists. When a text editor like <code>vim</code> starts, it
        tells the TTY to disable this interception so it can use Ctrl+C for its own commands
        instead of the kernel killing the process. Raw mode turns off the line discipline's
        special byte handling and passes everything through untouched. When <code>vim</code>
        exits, it restores the original settings &mdash; which is why your terminal acts
        strangely if a program crashes without cleaning up.
      </p>

      <h2>Ten windows open: the controlling terminal</h2>

      <p>
        A single user might have ten terminal windows open, each with its own PTY. If a
        background process needs to prompt for a password, which window does the prompt appear
        in? If a daemon needs to log a message to "the terminal," which one?
      </p>
      <p>
        <strong>The need:</strong> an association between a process and a specific TTY device.
      </p>
      <p>
        <strong>The solution:</strong> the controlling terminal. When a session is started (by
        logging in or opening a terminal window), the shell is "married" to a specific PTY. That
        PTY becomes the controlling terminal for the entire session. Every process spawned by that
        shell inherits the association.
      </p>
      <p>
        You can see this directly. Run <code>tty</code> in any terminal window and it prints the
        slave device &mdash; <code>/dev/pts/1</code>, <code>/dev/pts/3</code>, whatever PTY that
        window is connected to. That's your controlling terminal.
      </p>
      <p>
        This association matters because signals like SIGHUP (more on that shortly) are delivered
        to processes via their controlling terminal. If the controlling terminal goes away, the
        kernel knows which processes to notify.
      </p>

      <h2>Across the network: SSH and nested PTYs</h2>

      <p>
        Everything so far happens on a single machine. SSH extends it across a network, and the
        way it does so is worth understanding because it reuses every concept above.
      </p>
      <p>
        When you sit at your laptop and run <code>ssh user@server</code>, your local terminal is
        already a PTY pair &mdash; your terminal emulator holds the master, your local shell is
        on the slave. Now you need to make a program on a machine 3,000 miles away believe it has
        a local terminal.
      </p>
      <p>
        <strong>The need:</strong> trick a remote shell into thinking it's talking to local
        hardware.
      </p>
      <p>
        <strong>The solution:</strong> the SSH daemon (<code>sshd</code>) acts as a proxy
        terminal emulator. Here's the full chain:
      </p>
      <ol>
        <li>Your local SSH client sends your keystrokes over an encrypted tunnel.</li>
        <li>On the remote server, <code>sshd</code> receives the packets.</li>
        <li><code>sshd</code> opens a <em>new</em> PTY pair on the remote machine.</li>
        <li><code>sshd</code> takes the master side and spawns your remote shell
          (<code>bash</code>) on the slave side.</li>
      </ol>
      <pre>
 Your laptop                          Remote server
 ──────────                          ─────────────
 Keyboard                              bash (remote)
    │                                     │
    ▼                                     │
 Alacritty                            PTY Slave
    │                                     │
 PTY Master ── local ── PTY Slave    PTY Master
                shell       │             │
                         ssh client ═══ sshd
                              (encrypted tunnel)</pre>
      <p>
        The remote <code>bash</code> has no idea it's being controlled from another continent. It
        sees a PTY slave and behaves exactly as it would locally. <code>sshd</code> is just
        another terminal emulator &mdash; instead of drawing pixels in a window, it relays bytes
        over a network.
      </p>

      <h2>What can your terminal do? Environment negotiation</h2>

      <p>
        The remote server has no idea what your local terminal window is capable of. Does it
        support 256 colors? Can it underline text? Does it understand the escape sequences for
        moving the cursor?
      </p>
      <p>
        <strong>The need:</strong> the remote software (<code>vim</code>, <code>htop</code>,
        <code>top</code>) needs to know which "instruction manual" to use for drawing to your
        specific terminal.
      </p>
      <p>
        <strong>The solution:</strong> the <code>$TERM</code> environment variable and the
        Terminfo database. When you connect via SSH, your client tells the remote
        <code>sshd</code>: "My user's terminal type is <code>xterm-256color</code>." The remote
        server sets <code>$TERM</code> accordingly, and programs look up that terminal type in
        Terminfo to find the right escape sequences.
      </p>
      <p>
        If you've ever seen colors break, the backspace key print <code>^H</code> instead of
        deleting, or <code>vim</code> draw garbage when you SSH from an unusual device, it's
        almost certainly because the remote server doesn't have the Terminfo entry for the
        <code>$TERM</code> value your local machine sent. The instruction manual is missing, so
        the software guesses wrong.
      </p>

      <h2>The connection drops: multiplexers</h2>

      <p>
        You're running a long build over SSH and your Wi-Fi cuts out. The SSH connection dies.
        Because the remote <code>bash</code> was married to the PTY slave owned by the
        <code>sshd</code> master, when <code>sshd</code> exits, the master side of the PTY
        closes, the kernel destroys the PTY, and <code>bash</code> &mdash; along with your
        build &mdash; is killed.
      </p>
      <p>
        <strong>The need:</strong> a way to keep a terminal session alive even when the
        connection that created it disappears.
      </p>
      <p>
        <strong>The solution:</strong> terminal multiplexers like <code>tmux</code> and
        <code>screen</code>. A multiplexer inserts itself between the SSH connection and the
        shell:
      </p>
      <ol>
        <li><code>tmux</code> opens its own PTY pair for your shell.</li>
        <li><code>tmux</code> takes the master side. Your shell runs on the slave side.</li>
        <li>The SSH connection is now talking to <code>tmux</code>, not directly to the
          shell.</li>
      </ol>
      <p>
        When your Wi-Fi dies, <code>sshd</code> closes, and the outer PTY is destroyed. But
        <code>tmux</code> is a local process on the server &mdash; it doesn't care about the
        network. It keeps running, and the inner PTY (the one your shell is attached to) stays
        alive. When you reconnect and run <code>tmux attach</code>, you're hooking a new SSH
        master into the existing <code>tmux</code> process. Your shell never noticed you left.
      </p>
      <p>
        The word "pseudo" in pseudoterminal earns its keep here. The PTY is a simulation of a
        wire, and simulations can be layered. <code>tmux</code> is a terminal emulator whose
        "display" is another terminal, all the way down.
      </p>

      <h2>Hanging up: SIGHUP</h2>

      <p>
        When you close a terminal window, every process inside it dies. This behaviour has a
        name and a history.
      </p>
      <p>
        In the modem era, "hanging up" meant physically disconnecting the phone line. The modem
        detected the loss of carrier signal, and the kernel needed a way to tell the programs on
        the other end that their user was gone.
      </p>
      <p>
        <strong>The need:</strong> a clean way to tell all child processes to stop when the
        connection is severed.
      </p>
      <p>
        <strong>The solution:</strong> SIGHUP &mdash; Signal Hangup. When the master side of a
        PTY is closed (you click the X on your terminal window, your SSH connection drops, or
        your Wi-Fi dies), the kernel sends SIGHUP to the session leader on the slave side.
        The session leader &mdash; typically your shell &mdash; then sends SIGHUP to its child
        processes. Unless a program is specifically configured to ignore it, it exits.
      </p>
      <p>
        This is why <code>nohup</code> exists. Running <code>nohup ./long-task &amp;</code> tells
        the process to ignore SIGHUP, so it survives the controlling terminal being closed.
        It's also why <code>tmux</code> works &mdash; the inner PTY's master (<code>tmux</code>
        itself) doesn't close when the outer connection dies, so no SIGHUP is sent to your shell.
      </p>
      <p>
        The signal's name is an artifact of physical hardware, but the mechanism is alive in
        every terminal window you close.
      </p>

      <h2>The shape of it</h2>

      <p>
        Every layer in this system exists because someone needed to solve a specific problem
        without breaking the contract established by the layer below. The PTY exists because
        windows aren't wires. SIGWINCH exists because windows can resize and wires couldn't.
        The line discipline exists because stuck programs can't read their input. The controlling
        terminal exists because users have more than one window. SSH nests the whole thing across
        a network. Multiplexers add persistence. SIGHUP cleans up when it all falls apart.
      </p>
      <p>
        None of it was designed as a unified system. It accumulated, one need at a time, each
        solution preserving the interface that programs already depended on. The result is
        something that looks baroque from the outside but makes sense when you trace the
        path that got us here.
      </p>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
