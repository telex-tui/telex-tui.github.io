<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Terminals: Why They Evolved the Way They Did - Telex</title>
  <meta name="description" content="A needs-first history of terminal devices in Unix: from physical teletypes to PTYs, signals, SSH, and multiplexers. Each concept motivated by the problem it solved.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Terminals: Why They Evolved the Way They Did</h1>
      <div class="post-meta">February 2026</div>

      <h2>Someone needs to use the computer</h2>

      <p>
        In the 1960s and 70s, a computer was the size of a room and cost more than a house. A
        university or a company might own one. Dozens of people needed to use it, but you
        couldn't walk up to the machine and type &mdash; it had no keyboard, no screen. The
        computer itself was just a processor, memory, and storage in a rack. If you wanted to
        interact with it, you needed a separate device: something with a keyboard for input and
        some way to see output.
      </p>
      <p>
        That device was the <strong>terminal</strong>. The word means exactly what it sounds
        like &mdash; the end of the line, the point where a human meets the machine. The first
        widely-used terminals were built by the Teletype Corporation: a keyboard and a printer in
        one unit. You typed a character, it traveled down a cable to the computer, the computer
        processed it and sent characters back, and the Teletype printed them on paper. That's
        where the abbreviation "TTY" comes from. It's short for Teletype.
      </p>
      <p>
        The cable between the terminal and the computer was a serial line &mdash; a wire that
        carried data one bit at a time, like Morse code down a telegraph wire. Every terminal
        had its own cable running back to the computer. A university might have twenty
        Teletypes scattered across a building, all wired into the same machine.
      </p>

      <h2>The contract</h2>

      <p>
        On the computer's side, the operating system kernel had a simple job. For each serial
        cable, it read bytes coming in, handed them to whatever program the user was running, took
        that program's output bytes, and sent them back down the same cable. The kernel
        represented each cable as a device file &mdash; <code>/dev/ttyS0</code> for the first
        serial port, <code>/dev/ttyS1</code> for the second, and so on.
      </p>
      <p>
        Programs didn't know or care what was on the other end of that file. They read input from
        a file descriptor and wrote output to one. Whether it was a Teletype printing on paper or
        a newer video terminal painting characters on a CRT screen, the program saw the same
        thing: a stream of bytes in, a stream of bytes out.
      </p>
      <p>
        This simplicity became a contract. Software was written around it. Shells, editors, compilers &mdash;
        everything assumed it was talking to a character device mediated by the kernel. And that
        contract turned out to be so useful that when the physical hardware disappeared, nobody
        was willing to break it. Every complication that follows exists because the world changed
        but the contract had to be preserved.
      </p>

      <h2>The wire disappears</h2>

      <p>
        By the mid-1980s, computers shrank. Instead of a room-sized mainframe shared by dozens
        of people, you might have a workstation on your desk with its own screen and keyboard.
        There was no cable anymore &mdash; the "terminal" was just a window in a graphical
        interface. But all the software still expected a TTY. Programs like <code>bash</code>
        were written to read and write a character device. A window on a graphical display isn't
        a serial port. It has no device file. It's just pixels managed by a GUI application.
      </p>
      <p>
        So the kernel learned to fake it. The pseudoterminal, or PTY, is a virtual cable: a
        pair of connected endpoints created in software.
      </p>
      <ul>
        <li>One end &mdash; the <strong>slave</strong> side (<code>/dev/pts/0</code>,
          <code>/dev/pts/1</code>, etc.) &mdash; behaves exactly like a physical TTY.
          The shell attaches here. As far as <code>bash</code> is concerned, it's talking to
          a serial port.</li>
        <li>The other end &mdash; the <strong>master</strong> side &mdash; is held by the
          terminal emulator, the application drawing the window on screen (Alacritty, GNOME
          Terminal, iTerm2, or anything else that displays that black rectangle with
          text in it).</li>
      </ul>
      <p>
        When you type a character in your terminal window, the emulator writes it to the master
        end. The kernel passes it through to the slave end, where the shell reads it. When the
        shell produces output, it writes to the slave, the kernel passes it to the master, and
        the emulator draws the characters in its window.
      </p>
      <pre>
 You type 'l' 's' '\n'
        │
        ▼
 Terminal Emulator (Alacritty)
        │
        ▼
   PTY Master ──── kernel ──── PTY Slave (/dev/pts/1)
                                   │
                                   ▼
                                 bash
                                   │
                                   ▼
                          "file1.txt  file2.txt\n"
                                   │
                            (back through the PTY)
                                   │
                                   ▼
                          drawn in your window</pre>
      <p>
        The entire point is deception. Programs that expect a hardware cable get a software
        imitation of one. The slave end is the fake cable. The master end is what's really there.
        The contract is preserved.
      </p>

      <h2>Windows can resize</h2>

      <p>
        A physical Teletype had a fixed width &mdash; however wide the paper roll was. A CRT
        terminal had fixed dimensions too, built into the hardware. But a window on a graphical
        desktop can be dragged to any size. Programs that draw full-screen layouts &mdash;
        <code>vim</code>, <code>htop</code>, anything with columns and borders &mdash; need to
        know the current dimensions. And when you grab a corner and resize the window while the
        program is running, it needs to know <em>that</em> too.
      </p>
      <p>
        There's no way for a program to poll for size changes. Instead, when you resize the
        window, the terminal emulator tells the kernel the new dimensions, and the kernel
        delivers a signal called SIGWINCH (Signal Window Change) directly to the running program.
        The program catches the signal, asks the kernel for the new width and height, and redraws
        itself.
      </p>
      <p>
        This is why full-screen terminal programs redraw correctly when you resize the window,
        and why they don't if they weren't written to handle SIGWINCH. You either listen for that
        signal or you never find out.
      </p>

      <h2>When a program won't listen</h2>

      <p>
        You run a program. It gets stuck in an infinite loop. You press Ctrl+C and it stops. But
        think about what just happened &mdash; the program was too busy looping to read its
        input. It was never going to see that Ctrl+C keystroke in its input buffer. So how did it
        get killed?
      </p>
      <p>
        Between the master and slave ends of every PTY, the kernel has a layer called the
        <strong>line discipline</strong>. It watches every byte flowing through the virtual cable.
        Most bytes pass straight through. But certain ones are special. When the line discipline
        sees byte <code>0x03</code> &mdash; the code for Ctrl+C &mdash; it doesn't deliver it
        to the program's input buffer. Instead, the kernel converts it into a signal (SIGINT) and
        delivers it directly to the process, bypassing the input queue entirely. The program
        doesn't need to cooperate. The kernel reaches in and interrupts it.
      </p>
      <p>
        This works for other key combinations too. Ctrl+Z sends SIGTSTP to suspend a process.
        Ctrl+\ sends SIGQUIT to kill it with a core dump. The line discipline intercepts all of
        them.
      </p>
      <p>
        But sometimes a program <em>wants</em> those keys for itself. When <code>vim</code>
        starts, it puts the terminal into "raw mode" &mdash; telling the line discipline to stop
        intercepting special bytes and pass everything through untouched. That's how
        <code>vim</code> can use Ctrl+C for its own commands instead of being killed. When
        <code>vim</code> exits, it restores the original settings. If a program crashes without
        cleaning up, the terminal stays in raw mode &mdash; which is why your shell sometimes
        acts strangely after a crash, and why <code>reset</code> exists to fix it.
      </p>

      <h2>Which window?</h2>

      <p>
        On the old mainframe, each user had one terminal, one cable, one session. But with
        graphical desktops, a single user might have ten terminal windows open, each with its own
        PTY. If a background process needs to prompt for a password, which window does the prompt
        appear in?
      </p>
      <p>
        The answer is the <strong>controlling terminal</strong>. When you open a terminal window,
        the shell that starts inside it is "married" to that window's PTY. That PTY becomes the
        controlling terminal for everything launched from that shell. You can see which one it is
        by running <code>tty</code> &mdash; it prints the device path, something like
        <code>/dev/pts/3</code>.
      </p>
      <p>
        This matters for more than just prompts. When the controlling terminal goes away &mdash;
        the window closes, the connection drops &mdash; the kernel uses this association to figure
        out which processes need to be told about it.
      </p>

      <h2>Using a computer across the internet</h2>

      <p>
        Everything so far happens on a single machine. But sometimes the computer you need to
        use is in a data center on the other side of the country. You're sitting at your laptop
        and you need a shell on that remote machine. The problem is the same one from the 1960s
        &mdash; you need to interact with a computer that isn't in front of you &mdash; but now
        the cable is the internet instead of a serial wire.
      </p>
      <p>
        When you run <code>ssh user@server</code>, the SSH daemon on the remote machine
        does something familiar: it creates a PTY pair. It takes the master side and spawns
        <code>bash</code> on the slave side, just like a terminal emulator would. The only
        difference is that instead of drawing characters in a window, <code>sshd</code> sends
        them through an encrypted network tunnel back to the SSH client on your laptop, which
        passes them to your local terminal emulator for display.
      </p>
      <pre>
 Your laptop                          Remote server
 ──────────                          ─────────────
 Keyboard                              bash (remote)
    │                                     │
    ▼                                     │
 Alacritty                            PTY Slave
    │                                     │
 PTY Master ── local ── PTY Slave    PTY Master
                shell       │             │
                         ssh client ═══ sshd
                              (encrypted tunnel)</pre>
      <p>
        The remote <code>bash</code> has no idea it's being controlled from another continent. It
        sees a PTY slave and behaves as if someone were sitting right next to the machine.
        <code>sshd</code> is just another terminal emulator &mdash; it fakes the cable, same as
        Alacritty does.
      </p>

      <h2>The remote machine doesn't know your terminal</h2>

      <p>
        There's a catch when working remotely. The software on the server &mdash;
        <code>vim</code>, <code>htop</code>, anything that draws to the screen &mdash; needs to
        know what your terminal can do. Does it support 256 colors? Can it underline text? What
        escape sequences does it understand for moving the cursor around?
      </p>
      <p>
        When you connect, your SSH client sends along a piece of information: "My user's terminal
        type is <code>xterm-256color</code>" (or whatever it happens to be). The remote server
        stores this in the <code>$TERM</code> environment variable, and programs look it up in
        a database called Terminfo to find the right escape sequences for your terminal.
      </p>
      <p>
        If you've ever seen colors break, the backspace key print <code>^H</code> instead of
        deleting, or <code>vim</code> draw garbage after connecting from an unusual device, it's
        almost certainly because the remote server doesn't have a Terminfo entry matching the
        <code>$TERM</code> value your client sent. The lookup fails, the software guesses, and it
        guesses wrong.
      </p>

      <h2>When the connection drops</h2>

      <p>
        You're running a long build over SSH and your Wi-Fi cuts out. The SSH connection dies.
        The remote <code>sshd</code> process exits, which closes the master end of the PTY it
        was holding. The kernel destroys the PTY. And <code>bash</code> &mdash; along with your
        build &mdash; is killed. All your work, gone, because a wireless signal wobbled for a
        few seconds.
      </p>
      <p>
        Terminal multiplexers like <code>tmux</code> and <code>screen</code> fix this by adding
        another layer of indirection. Instead of SSH connecting directly to your shell,
        <code>tmux</code> sits in between. It creates its own PTY pair: <code>tmux</code> holds
        the master end, your shell runs on the slave end. The SSH connection talks to
        <code>tmux</code>, not to the shell.
      </p>
      <p>
        Now when your Wi-Fi dies and <code>sshd</code> exits, only the outer connection is lost.
        <code>tmux</code> is a local process on the server &mdash; it doesn't care about the
        network. It keeps running, and the inner PTY stays alive. When you reconnect and run
        <code>tmux attach</code>, you're hooking a new SSH session into the existing
        <code>tmux</code> process. Your shell never noticed you left.
      </p>
      <p>
        The word "pseudo" in pseudoterminal earns its keep here. The PTY is a simulation of a
        cable, and simulations can be layered &mdash; one fake cable inside another, as deep as
        you need.
      </p>

      <h2>Closing the window</h2>

      <p>
        When you close a terminal window, every process inside it dies. This happens automatically
        and most people never think about it. The mechanism behind it has a name that's an
        artifact from a different era.
      </p>
      <p>
        Before the internet, people connected to remote computers over phone lines using modems.
        "Hanging up" meant physically disconnecting the call. The modem would detect the loss of
        signal, and the kernel needed a way to tell the programs on the other end that their user
        was gone. The signal it sends is called SIGHUP &mdash; Signal Hangup.
      </p>
      <p>
        The mechanism survived long after the phone modems disappeared. Today, when the master end
        of any PTY closes &mdash; you click the X on a terminal window, your SSH connection
        drops, your Wi-Fi dies &mdash; the kernel sends SIGHUP to the session leader on the slave
        side. The session leader is typically your shell, and the shell passes the signal along to
        its child processes. Unless a program is specifically configured to ignore it, it exits.
      </p>
      <p>
        This is why <code>nohup</code> exists. Running <code>nohup ./long-task &amp;</code>
        tells the process to ignore SIGHUP, so it survives when the terminal closes.
        It's also why <code>tmux</code> works for keeping sessions alive &mdash; the inner
        PTY's master is <code>tmux</code> itself, which doesn't close when the outer connection
        dies, so no SIGHUP reaches your shell.
      </p>

      <h2>The shape of it</h2>

      <p>
        None of this was designed as a unified system. It accumulated over decades, one problem
        at a time. People needed to use a computer, so they built terminals. The computer needed
        a protocol, so software was written around a character device. The hardware went away but
        the software remained, so the kernel learned to fake the hardware. Windows could resize but
        programs couldn't tell, so a signal was added. Programs could get stuck and ignore their
        input, so the kernel learned to intercept special keystrokes. Users opened many
        windows, so each session was tied to a specific device. Computers moved across the
        network, so the virtual cable trick was played again over an encrypted tunnel. Connections
        dropped, so another layer of fake cable was inserted to absorb the failure.
      </p>
      <p>
        Each solution preserved the contract that programs already depended on. From the outside,
        the result looks baroque. From the inside &mdash; following the path that got us
        here &mdash; each step makes sense. It was always the simplest thing that could work,
        given what already existed.
      </p>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
