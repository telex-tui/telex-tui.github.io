<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #1: Newtype - Telex</title>
  <meta name="description" content="Wrap a primitive in a single-field tuple struct and the compiler catches type confusion at zero cost. Also the standard workaround for the orphan rule.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #1: Newtype</h1>
      <div class="post-meta">June 2026</div>
      <p class="series-nav">Post 1 of 22 in <a href="#series-index">Rust Patterns That Matter</a>. Companion series: <a href="chat-server-hello-tcp.html">Building a Chat Server in Rust</a>.</p>

      <p>
        Two function parameters have the same type. A caller swaps them by accident. The
        program compiles, runs, and produces wrong results. The type system could have caught
        this, but both parameters were <code>u64</code> and the compiler can't tell them
        apart.
      </p>

      <h2>The motivation</h2>

      <pre><code><span class="kw">fn</span> <span class="fn">transfer</span>(from: <span class="ty">u64</span>, to: <span class="ty">u64</span>, amount: <span class="ty">u64</span>) {
    <span class="cm">// ...</span>
}

<span class="cm">// Oops: swapped from and to</span>
<span class="fn">transfer</span>(recipient_id, sender_id, <span class="num">500</span>);</code></pre>

      <p>
        This compiles. All three arguments are <code>u64</code>. The compiler has no way
        to know that <code>from</code> is a sender and <code>to</code> is a recipient.
        You might try type aliases:
      </p>

      <pre><code><span class="kw">type</span> <span class="ty">UserId</span> = <span class="ty">u64</span>;
<span class="kw">type</span> <span class="ty">Amount</span> = <span class="ty">u64</span>;

<span class="kw">fn</span> <span class="fn">transfer</span>(from: <span class="ty">UserId</span>, to: <span class="ty">UserId</span>, amount: <span class="ty">Amount</span>) { <span class="cm">/*...*/</span> }</code></pre>

      <p>
        But type aliases are transparent. <code>UserId</code> and <code>u64</code> are
        the same type to the compiler. You can still pass an <code>Amount</code> where a
        <code>UserId</code> is expected. No protection.
      </p>

      <h2>The pattern: newtype</h2>

      <p>
        Wrap the inner type in a single-field tuple struct:
      </p>

      <pre><code><span class="kw">struct</span> <span class="ty">UserId</span>(<span class="ty">u64</span>);
<span class="kw">struct</span> <span class="ty">OrderId</span>(<span class="ty">u64</span>);
<span class="kw">struct</span> <span class="ty">Amount</span>(<span class="ty">u64</span>);

<span class="kw">fn</span> <span class="fn">transfer</span>(from: <span class="ty">UserId</span>, to: <span class="ty">UserId</span>, amount: <span class="ty">Amount</span>) {
    <span class="cm">// ...</span>
}

<span class="kw">fn</span> <span class="fn">main</span>() {
    <span class="kw">let</span> sender = <span class="ty">UserId</span>(<span class="num">42</span>);
    <span class="kw">let</span> recipient = <span class="ty">UserId</span>(<span class="num">99</span>);
    <span class="kw">let</span> amount = <span class="ty">Amount</span>(<span class="num">500</span>);

    <span class="fn">transfer</span>(sender, recipient, amount); <span class="cm">// OK</span>

    <span class="kw">let</span> order = <span class="ty">OrderId</span>(<span class="num">7</span>);
    <span class="cm">// transfer(order, recipient, amount);</span>
    <span class="cm">// ERROR: expected `UserId`, found `OrderId`</span>
}</code></pre>

      <p>
        <code>UserId</code>, <code>OrderId</code>, and <code>Amount</code> are now
        distinct types. Passing an <code>OrderId</code> where a <code>UserId</code> is
        expected is a compile error. The type system catches the bug.
      </p>

      <h2>Zero-cost abstraction</h2>

      <p>
        A newtype compiles to exactly the same machine code as the inner type. There's no
        wrapper struct at runtime, no indirection, no overhead. <code>UserId(42)</code>
        is just <code>42</code> in memory. The distinction exists only in the type system,
        and the type system is erased at compile time.
      </p>

      <h2>The orphan rule workaround</h2>

      <p>
        Rust's orphan rule prevents you from implementing a foreign trait on a foreign type.
        You can't write <code>impl Display for Vec&lt;u8&gt;</code> in your crate -
        both <code>Display</code> and <code>Vec</code> are defined elsewhere.
      </p>
      <p>
        The newtype pattern gives you a local type to attach the impl to:
      </p>

      <pre><code><span class="kw">use</span> std::fmt;

<span class="kw">struct</span> <span class="ty">Bytes</span>(<span class="ty">Vec</span>&lt;<span class="ty">u8</span>&gt;);

<span class="kw">impl</span> fmt::<span class="ty">Display</span> <span class="kw">for</span> <span class="ty">Bytes</span> {
    <span class="kw">fn</span> <span class="fn">fmt</span>(&amp;<span class="kw">self</span>, f: &amp;<span class="kw">mut</span> fmt::<span class="ty">Formatter</span>) -&gt; fmt::<span class="ty">Result</span> {
        <span class="fn">write!</span>(f, <span class="str">"{} bytes"</span>, <span class="kw">self</span>.<span class="num">0</span>.<span class="fn">len</span>())
    }
}</code></pre>

      <p>
        <code>Bytes</code> is a type in your crate, so you can implement any trait on it.
        Inside, it's just a <code>Vec&lt;u8&gt;</code>.
      </p>

      <h2>Accessing the inner value</h2>

      <p>
        The simplest approach: access the field directly with <code>.0</code>:
      </p>

      <pre><code><span class="kw">let</span> id = <span class="ty">UserId</span>(<span class="num">42</span>);
<span class="kw">let</span> raw: <span class="ty">u64</span> = id.<span class="num">0</span>;</code></pre>

      <p>
        For a more explicit API, add a method:
      </p>

      <pre><code><span class="kw">impl</span> <span class="ty">UserId</span> {
    <span class="kw">fn</span> <span class="fn">as_u64</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">u64</span> { <span class="kw">self</span>.<span class="num">0</span> }
}</code></pre>

      <p>
        You can also implement <code>Deref&lt;Target = u64&gt;</code> to make the newtype
        transparent for reads. But be deliberate - <code>Deref</code> makes the
        compiler automatically coerce <code>&amp;UserId</code> to <code>&amp;u64</code>,
        which weakens the type safety you added. If you want <code>UserId</code> and
        <code>u64</code> to be interchangeable for reads, implement <code>Deref</code>.
        If you want the distinction enforced everywhere, don't.
      </p>

      <h2>Deriving traits</h2>

      <p>
        Newtypes often need the same traits as their inner type. Use derive:
      </p>

      <pre><code><span class="kw">#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
<span class="kw">struct</span> <span class="ty">UserId</span>(<span class="ty">u64</span>);</code></pre>

      <p>
        This gives you hashing (for <code>HashMap</code> keys), equality, debug printing,
        and cheap copies - everything you'd expect from a <code>u64</code> wrapper.
      </p>

      <h2>When to use it</h2>

      <ul>
        <li><strong>Type safety for IDs:</strong> <code>UserId</code> vs <code>OrderId</code>
          vs <code>ProductId</code></li>
        <li><strong>Units of measurement:</strong> <code>Meters(f64)</code> vs
          <code>Seconds(f64)</code></li>
        <li><strong>Orphan rule workaround:</strong> implementing foreign traits on foreign types</li>
        <li><strong>Restricting APIs:</strong> a <code>NonEmpty(Vec&lt;T&gt;)</code> that
          enforces the vector is never empty at construction time</li>
        <li><strong>Type-safe indices:</strong> <code>NodeId(usize)</code> for arenas
          (<a href="rust-patterns-index-based-design.html">#8</a>)</li>
      </ul>
      <p>
        When not to: if you genuinely want the types to be interchangeable (a
        <code>type</code> alias is fine), or if the wrapping adds ceremony without catching
        real bugs.
      </p>

      <p>
        <em>See it in practice:</em> <a href="chat-server-hello-tcp.html">Building a Chat Server #1: Hello, TCP</a>
        uses this pattern for type-safe <code>UserId</code> and <code>RoomId</code>.
      </p>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><strong>#1: Newtype</strong></li>
          <li><a href="rust-patterns-from-into.html">#2: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#3: Error Handling</a></li>
          <li><a href="rust-patterns-interior-mutability.html">#4: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#5: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#6: The Combo - Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#7: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#8: Index-Based Design</a></li>
          <li><a href="rust-patterns-drop-raii.html">#9: Drop and RAII</a></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#10: Lifetime Annotations</a></li>
          <li><a href="rust-patterns-cow.html">#11: Cow - Borrow or Own</a></li>
          <li><a href="rust-patterns-iterators.html">#12: Custom Iterators</a></li>
          <li><a href="rust-patterns-static-clone.html">#13: 'static + Clone</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-closure-traits.html">#15: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#16: Storing and Returning Closures</a></li>
          <li><a href="rust-patterns-builder.html">#17: Builder Pattern</a></li>
          <li><a href="rust-patterns-typestate.html">#18: Typestate</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#19: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#20: Channels - Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#21: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#22: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT - Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
