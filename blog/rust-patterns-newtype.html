<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust Patterns #11: Newtype - Telex</title>
  <meta name="description" content="Wrap a primitive in a single-field tuple struct and the compiler catches type confusion at zero cost. Also the standard workaround for the orphan rule.">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" type="image/png" href="../assets/telex-tui.png">
</head>
<body>
  <header>
    <div class="container">
      <a href="/" class="logo-link">
        <img src="../assets/telex-tui.png" alt="Telex logo">
        Telex
      </a>
      <nav>
        <a href="https://telex-tui.github.io/telex-tui/">Book</a>
        <a href="/blog/">Blog</a>
        <a href="https://github.com/telex-tui/telex-tui">GitHub</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <article class="post">
      <h1>Rust Patterns That Matter #11: Newtype</h1>
      <div class="post-meta">June 2026</div>
      <p class="series-nav">Post 11 of 20 in <a href="#series-index">Rust Patterns That Matter</a>.</p>

      <p>
        Two function parameters are both <code>u64</code>. A caller swaps them by accident.
        The program compiles, runs, and gives wrong results. The type system could have
        caught this, but the compiler sees two <code>u64</code>s and can't tell them apart.
      </p>

      <h2>The motivation</h2>

      <pre><code><span class="kw">fn</span> <span class="fn">transfer</span>(from: <span class="ty">u64</span>, to: <span class="ty">u64</span>, amount: <span class="ty">u64</span>) {
    <span class="cm">// ...</span>
}

<span class="cm">// Oops: swapped from and to</span>
<span class="fn">transfer</span>(recipient_id, sender_id, <span class="num">500</span>);</code></pre>

      <p>
        This compiles. All three arguments are <code>u64</code>. The compiler has no way
        to know that <code>from</code> is a sender and <code>to</code> is a recipient.
        You might try type aliases:
      </p>

      <pre><code><span class="kw">type</span> <span class="ty">UserId</span> = <span class="ty">u64</span>;
<span class="kw">type</span> <span class="ty">Amount</span> = <span class="ty">u64</span>;

<span class="kw">fn</span> <span class="fn">transfer</span>(from: <span class="ty">UserId</span>, to: <span class="ty">UserId</span>, amount: <span class="ty">Amount</span>) { <span class="cm">/*...*/</span> }</code></pre>

      <p>
        But type aliases don't create new types. To the compiler, <code>UserId</code> is
        still just <code>u64</code>. You can pass an <code>Amount</code> where a
        <code>UserId</code> is expected and nothing stops you.
      </p>

      <h2>The pattern: newtype</h2>

      <p>
        Wrap the inner type in a single-field tuple struct:
      </p>

      <pre><code><span class="kw">struct</span> <span class="ty">UserId</span>(<span class="ty">u64</span>);
<span class="kw">struct</span> <span class="ty">OrderId</span>(<span class="ty">u64</span>);
<span class="kw">struct</span> <span class="ty">Amount</span>(<span class="ty">u64</span>);

<span class="kw">fn</span> <span class="fn">transfer</span>(from: <span class="ty">UserId</span>, to: <span class="ty">UserId</span>, amount: <span class="ty">Amount</span>) {
    <span class="cm">// ...</span>
}

<span class="kw">fn</span> <span class="fn">main</span>() {
    <span class="kw">let</span> sender = <span class="ty">UserId</span>(<span class="num">42</span>);
    <span class="kw">let</span> recipient = <span class="ty">UserId</span>(<span class="num">99</span>);
    <span class="kw">let</span> amount = <span class="ty">Amount</span>(<span class="num">500</span>);

    <span class="fn">transfer</span>(sender, recipient, amount); <span class="cm">// OK</span>

    <span class="kw">let</span> order = <span class="ty">OrderId</span>(<span class="num">7</span>);
    <span class="cm">// transfer(order, recipient, amount);</span>
    <span class="cm">// ERROR: expected `UserId`, found `OrderId`</span>
}</code></pre>

      <p>
        <code>UserId</code>, <code>OrderId</code>, and <code>Amount</code> are now
        distinct types. Passing an <code>OrderId</code> where a <code>UserId</code> is
        expected is a compile error. The type system catches the bug.
      </p>

      <h2>Zero-cost abstraction</h2>

      <p>
        A newtype compiles down to the same machine code as the inner type. At runtime there
        is no wrapper, no indirection, no overhead. <code>UserId(42)</code> is just
        <code>42</code> in memory. The wrapper only exists while the compiler is checking
        your code; it's gone by the time the program runs.
      </p>

      <h2>The orphan rule workaround</h2>

      <p>
        Rust's orphan rule says you can't implement a trait on a type unless your crate
        owns at least one of them. So you can't write <code>impl Display for
        Vec&lt;u8&gt;</code> in your own crate &mdash; both <code>Display</code> and
        <code>Vec</code> belong to the standard library.
      </p>
      <p>
        A newtype gives you a type that your crate owns, so you can attach any impl to it:
      </p>

      <pre><code><span class="kw">use</span> std::fmt;

<span class="kw">struct</span> <span class="ty">Bytes</span>(<span class="ty">Vec</span>&lt;<span class="ty">u8</span>&gt;);

<span class="kw">impl</span> fmt::<span class="ty">Display</span> <span class="kw">for</span> <span class="ty">Bytes</span> {
    <span class="kw">fn</span> <span class="fn">fmt</span>(&amp;<span class="kw">self</span>, f: &amp;<span class="kw">mut</span> fmt::<span class="ty">Formatter</span>) -&gt; fmt::<span class="ty">Result</span> {
        <span class="fn">write!</span>(f, <span class="str">"{} bytes"</span>, <span class="kw">self</span>.<span class="num">0</span>.<span class="fn">len</span>())
    }
}</code></pre>

      <p>
        <code>Bytes</code> lives in your crate, so you can implement any trait on it.
        Under the hood, it's still just a <code>Vec&lt;u8&gt;</code>.
      </p>

      <h2>Accessing the inner value</h2>

      <p>
        The simplest approach: access the field directly with <code>.0</code>:
      </p>

      <pre><code><span class="kw">let</span> id = <span class="ty">UserId</span>(<span class="num">42</span>);
<span class="kw">let</span> raw: <span class="ty">u64</span> = id.<span class="num">0</span>;</code></pre>

      <p>
        For a more explicit API, add a method:
      </p>

      <pre><code><span class="kw">impl</span> <span class="ty">UserId</span> {
    <span class="kw">fn</span> <span class="fn">as_u64</span>(&amp;<span class="kw">self</span>) -&gt; <span class="ty">u64</span> { <span class="kw">self</span>.<span class="num">0</span> }
}</code></pre>

      <p>
        You can also implement <code>Deref&lt;Target = u64&gt;</code>, which lets you use a
        <code>&amp;UserId</code> anywhere a <code>&amp;u64</code> is expected. But be
        careful &mdash; <code>Deref</code> makes the compiler silently coerce
        <code>&amp;UserId</code> to <code>&amp;u64</code>, which chips away at the type
        safety you just added. If you're fine with reads going through as plain
        <code>u64</code>, implement <code>Deref</code>. If you want the distinction
        enforced everywhere, skip it.
      </p>

      <h2>Deriving traits</h2>

      <p>
        You'll usually want the same traits on the newtype as on the inner type. Derive them:
      </p>

      <pre><code><span class="kw">#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]</span>
<span class="kw">struct</span> <span class="ty">UserId</span>(<span class="ty">u64</span>);</code></pre>

      <p>
        Now you can use it as a <code>HashMap</code> key, compare two values, debug-print
        them, and copy them cheaply &mdash; everything you'd expect from a <code>u64</code>
        wrapper.
      </p>

      <h2>When to use it</h2>

      <ul>
        <li><strong>Type safety for IDs:</strong> <code>UserId</code> vs <code>OrderId</code>
          vs <code>ProductId</code></li>
        <li><strong>Units of measurement:</strong> <code>Meters(f64)</code> vs
          <code>Seconds(f64)</code></li>
        <li><strong>Orphan rule workaround:</strong> implementing a trait you don't own on a type you don't own</li>
        <li><strong>Restricting APIs:</strong> a <code>NonEmpty(Vec&lt;T&gt;)</code> whose
          constructor refuses to create an empty vector</li>
        <li><strong>Type-safe indices:</strong> <code>NodeId(usize)</code> for arenas
          (<a href="rust-patterns-index-based-design.html">#5</a>)</li>
      </ul>
      <p>
        When not to: if you actually want the types to be interchangeable (a
        <code>type</code> alias is fine for that), or if the wrapping just adds boilerplate
        without catching any real bugs.
      </p>

      <nav class="series-index" id="series-index">
        <h2>Series index</h2>
        <ol>
          <li><a href="rust-patterns-interior-mutability.html">#1: Interior Mutability</a></li>
          <li><a href="rust-patterns-shared-ownership.html">#2: Shared Ownership</a></li>
          <li><a href="rust-patterns-rc-refcell.html">#3: The Combo &mdash; Rc&lt;RefCell&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-split-borrows.html">#4: Split Borrows</a></li>
          <li><a href="rust-patterns-index-based-design.html">#5: Index-Based Design</a></li>
          <li><a href="rust-patterns-cow.html">#6: Cow &mdash; Borrow or Own</a></li>
          <li><a href="rust-patterns-lifetime-annotations.html">#7: Lifetime Annotations</a></li>
          <li><a href="rust-patterns-static-clone.html">#8: &rsquo;static + Clone</a></li>
          <li><a href="rust-patterns-closure-traits.html">#9: Fn, FnMut, FnOnce</a></li>
          <li><a href="rust-patterns-storing-closures.html">#10: Storing and Returning Closures</a></li>
          <li><strong>#11: Newtype</strong></li>
          <li><a href="rust-patterns-typestate.html">#12: Typestate</a></li>
          <li><a href="rust-patterns-builder.html">#13: Builder Pattern</a></li>
          <li><a href="rust-patterns-enum-dispatch.html">#14: Enum Dispatch vs Trait Objects</a></li>
          <li><a href="rust-patterns-from-into.html">#15: From / Into Conversions</a></li>
          <li><a href="rust-patterns-error-handling.html">#16: Error Handling</a></li>
          <li><a href="rust-patterns-arc-mutex.html">#17: Arc&lt;Mutex&lt;T&gt;&gt; vs Arc&lt;RwLock&lt;T&gt;&gt;</a></li>
          <li><a href="rust-patterns-channels.html">#18: Channels &mdash; Message Passing</a></li>
          <li><a href="rust-patterns-pin-futures.html">#19: Pin and Boxing Futures</a></li>
          <li><a href="rust-patterns-send-sync-async.html">#20: Send / Sync in Async</a></li>
        </ol>
      </nav>
    </article>
  </main>

  <footer>
    <div class="container">
      MIT &mdash; Copyright &copy; 2025 Mark Branion
    </div>
  </footer>
</body>
</html>
